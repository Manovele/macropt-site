<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="../assets/logo/mpt-logo.png" type="image/png">

<title data-i18n="meta.title">MacroPT Titanium – Planner Macro & Ricette</title>
<style>
  :root { --bg:#f6f7f8; --fg:#111214; --muted:#6b7077; --card:#ffffff; --brand:#b3764a; --ok:#2f6e5b; --bad:#a94a46; --warn:#b48a3a; --border:#e4e7ec; }
  * { box-sizing: border-box; }
  body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; background:var(--bg); color:var(--fg); }
  header {
    padding:4px 16px;
    background:white;
    border-bottom:1px solid var(--border);
    position:sticky;
    top:0;
    z-index:2;
}

  h1 { margin:0; font-size:20px; }
  .container { max-width: 1200px; margin: 8px auto; padding: 0 12px; }
  .row { display:grid; gap:12px; }
  @media (min-width:1000px){ .row-2 { grid-template-columns: 1fr 1fr; } }
.actions {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

  .card { background:var(--card); border:1px solid var(--border); border-radius:14px; padding:14px; box-shadow: 0 2px 8px rgba(0,0,0,.03); }
  .card h2 { font-size:16px; margin:0 0 10px 0; }
.peso-chart-wrapper {
  height: 260px;      /* puoi mettere 200–260 a gusto tuo */
  position: relative; /* richiesto da Chart.js in modalità responsive */
}
  label { font-size:12px; color:var(--muted); display:block; margin-bottom:4px; }
  input[type="number"], input[type="text"], select { width:100%; padding:10px 12px; border:1px solid var(--border); border-radius:10px; background:white; }
  input[readonly]{ background:#f3f4f6; }
  .grid { display:grid; gap:10px; }
  .grid-4 { grid-template-columns: repeat(4, 1fr); }
  .grid-12 { grid-template-columns: repeat(12, 1fr); }
  .btn { background:var(--brand); color:white; border:0; padding:9px 12px; border-radius:10px; cursor:pointer; }
  .btn:disabled { opacity:.6; cursor:not-allowed; }
  .btn-outline { background:white; color:var(--brand); border:1px solid var(--brand); }
  .btn-ghost { background:transparent; color:var(--muted); border:1px dashed var(--border); }
  .pill { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; font-size:12px; border-radius:999px; }
  .ok { color:var(--ok); border:1px solid #bbf7d0; background:#ecfdf5; }
  .bad { color:var(--bad); border:1px solid #fecaca; background:#fef2f2; }
  .warn { color:var(--warn); border:1px solid #fde68a; background:#fffbeb; }
  .muted { color:var(--muted); }
  .table { width:100%; border-collapse: collapse; }
  .table th, .table td { padding:8px; border-bottom:1px solid var(--border); font-size:14px; text-align:left; }
  .right { text-align:right; }
  /* Colonna grammi nelle tabelle dei pasti */
  .grams-cell {
    width: 80px;           /* se vuoi puoi scendere a 70px */
  }

  .grams-cell input {
    width: 100%;
    min-width: 70px;
    box-sizing: border-box;
    font-size: 14px;
  }

  .actions { display:flex; gap:8px; flex-wrap:wrap; }
  .small { font-size:12px; }
  .section-title { display:flex; gap:10px; align-items:center; justify-content:space-between; margin-bottom:6px; }
  .disclosure { display:flex; align-items:center; gap:8px; cursor:pointer; }
  .chev { transition: transform .2s ease; }
  .chev.open { transform: rotate(90deg); }
  .planner { overflow:auto; }
  .planner table { min-width: 800px; }
  .tag { font-size:11px; padding:2px 6px; border:1px solid var(--border); border-radius:999px; color:var(--muted); }
  .sticky-actions { display:flex; gap:8px; flex-wrap:wrap; }
  @media (max-width: 700px){
    .grid-4 { grid-template-columns: 1fr 1fr; }
  }
  .labelKcalInfo { color: var(--muted); font-style: italic; }
  .kcalLabelCell { color: var(--muted); font-style: italic; }
  .modal-backdrop{position:fixed; inset:0; background:rgba(0,0,0,.3); display:none; align-items:center; justify-content:center; z-index:50;}
  .modal{ background:var(--card); border:1px solid var(--border); border-radius:14px; box-shadow:0 10px 40px rgba(0,0,0,.2); width:min(900px, 92vw); max-height:80vh; overflow:auto; }
  .modal header{ position:sticky; top:0; background:white; border-bottom:1px solid var(--border); padding:12px 16px; display:flex; align-items:center; justify-content:space-between;}
  .modal .content{ padding:12px 16px;}
  .table.compact th, .table.compact td{ font-size:12px; padding:6px; }

/* ---- Titanium & Copper overrides ---- */
header { background:#ffffff !important; border-bottom:1px solid var(--border) !important; }
h1, .card h2 { color:#111214 !important; }
.card { background:var(--card) !important; border:1px solid var(--border) !important; box-shadow: 0 2px 8px rgba(16,24,40,0.05) !important; }

input[type="number"], input[type="text"], select {
  background:#ffffff !important;
  color:#111214 !important;
  border:1px solid var(--border) !important;
}
input[readonly]{ background:#f1f3f5 !important; color:#111214 !important; }
::placeholder { color:#6b7077 !important; opacity:.9; }

.btn { background:var(--brand) !important; color:#ffffff !important; border:0; }
.btn:hover { filter:brightness(1.06); }
.btn-outline { background:#ffffff !important; color:var(--brand) !important; border:1px solid var(--brand) !important; }
.btn-outline:hover { background: rgba(179,118,74,0.06) !important; }
.btn-outline.active {
  background: var(--brand) !important;
  color: #ffffff !important;
}

  /* Header utility buttons: lighter */
header .btn-outline.utility{
  padding: 5px 9px;
  font-size: 13px;
  border-color: rgba(179,118,74,0.45) !important;
  background: transparent !important;
}
header .btn-outline.utility:hover{
  background: rgba(179,118,74,0.08) !important;
}

  /* --- Dropdown menu top-right (Guida/Storico/Esporta/Importa) --- */
  header .dropdown{
    position: relative;
    display: inline-flex;
    align-items: center;
  }
  header .dropdown-menu{
    position: absolute;
    right: 0;
    top: calc(100% + 8px);
    min-width: 190px;
    background: #fff;
    border: 1px solid var(--border);
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.10);
    padding: 6px;
    display: none;
    z-index: 1000;
  }
  header .dropdown.open .dropdown-menu{
    display: block;
  }
  header .dropdown-item{
    width: 100%;
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    border-radius: 10px;
    border: 1px solid transparent;
    background: transparent;
    color: var(--text);
    font-size: 13px;
    cursor: pointer;
    text-align: left;
  }
  header .dropdown-item:hover{
    background: rgba(179,118,74,0.08);
    border-color: rgba(179,118,74,0.25);
  }

 
 /* Bottoni lingua planner (allineati a quelli della landing) */
  .lang-switch {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    margin-left: 8px;
  }

  .lang-btn {
    padding: 4px 10px;
    border-radius: 999px;
    font-size: 11px;
    border: 1px solid var(--brand);
    background: #ffffff;
    color: var(--brand);
    cursor: pointer;
  }

  .lang-btn.active {
    background: var(--brand);
    color: #ffffff;
  }


  /* Help drawer (right panel) */
  .help-overlay{
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.35);
    opacity: 0;
    pointer-events: none;
    transition: opacity 160ms ease;
    z-index: 9998;
  }
  .help-overlay.open{
    opacity: 1;
    pointer-events: auto;
  }

  .help-drawer{
    position: fixed;
    top: 0;
    right: 0;
    height: 100vh;
    width: min(420px, 92vw);
    background: #fff;
    border-left: 1px solid var(--border);
    box-shadow: -16px 0 40px rgba(0,0,0,0.12);
    transform: translateX(110%);
    transition: transform 220ms ease;
    z-index: 9999;
    display: flex;
    flex-direction: column;
  }
  .help-drawer.open{ transform: translateX(0); }

  .help-header{
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    padding: 14px 14px 10px 14px;
    border-bottom: 1px solid var(--border);
  }
  .help-title{
    font-weight: 800;
    font-size: 15px;
    color: var(--text);
  }
  .help-close{ white-space: nowrap; }

  .help-body{
    padding: 10px 14px 14px 14px;
    overflow: auto;
  }

  .help-accordion{
    display: grid;
    gap: 8px;
  }
  .help-acc-btn{
    width: 100%;
    text-align: left;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    padding: 10px 12px;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: rgba(179,118,74,0.06);
    color: var(--text);
    cursor: pointer;
    font-weight: 800;
  }
  .help-acc-panel{
    display: none;
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 10px 12px;
    background: #fff;
  }
  .help-acc-panel.open{ display: block; }
  .help-acc-content{
    font-size: 12.5px;
    line-height: 1.35;
    color: var(--text);
  }
  .help-acc-content ul{ margin: 8px 0 0 18px; }
  .help-acc-content li{ margin: 6px 0; }
  .help-acc-icon{ opacity: .7; }



.ok { color:#1f4439 !important; background:#e7f1ee !important; border:1px solid #cfe3dc !important; }
.warn { color:#5a4720 !important; background:#fbf3df !important; border:1px solid #f0e3bf !important; }
.bad { color:#5f2624 !important; background:#faeaea !important; border:1px solid #efcaca !important; }

.tag { border:1px solid var(--border) !important; color:#6b7077 !important; background:#fafbfc !important; }

.table th, .table td { border-bottom:1px solid var(--border) !important; color:#111214 !important; }
.muted, .small.muted { color:#6b7077 !important; }

.labelKcalInfo, .kcalLabelCell { color:#6b7077 !important; }
  /* --- Toast Notifications --- */
  #toast {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 12px 20px;
    border-radius: 10px;
    font-size: 14px;
    color: #ffffff;
    display: none;
    z-index: 9999;
    background: rgba(0,0,0,0.80);
    backdrop-filter: blur(4px);
    box-shadow: 0 4px 14px rgba(0,0,0,0.3);
    transition: opacity 0.3s ease;
  }

.recipes-stickybar{
  position: sticky;
  top: 64px;              /* se il tuo header è più alto, alza questo numero */
  background: var(--card);
  padding: 8px 0;
  z-index: 20;
}

</style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.48.0/dist/umd/supabase.min.js"></script>
</head>
<body>
  <div id="toast"></div>
  <div id="auth-screen" style="min-height:100vh; display:flex; align-items:center; justify-content:center; flex-direction:column; gap:12px;">
    <h2 data-i18n="auth.title">MacroPlanner Titanium</h2>
    <p data-i18n="auth.subtitle" style="color:#666; font-size:14px;">
      Accedi con email e password per usare il planner.
    </p>


    <div style="display:flex; flex-direction:column; gap:8px; width:min(320px, 90vw);">
      <div>
        <label for="loginEmail" data-i18n="auth.emailLabel" style="font-size:12px; color:#666;">
          Email
        </label>

        <input id="loginEmail" type="email" placeholder="you@example.com"
               style="width:100%; padding:8px 10px; border-radius:8px; border:1px solid #ccc;">
      </div>

      <div>
        <label for="loginPassword" data-i18n="auth.passwordLabel" style="font-size:12px; color:#666;">
          Password
        </label>

        <input id="loginPassword" type="password" placeholder="••••••••"
               style="width:100%; padding:8px 10px; border-radius:8px; border:1px solid #ccc;">
      </div>

      <button id="loginBtn" class="btn" data-i18n="auth.loginButton" style="text-align:center; width:100%; display:flex; justify-content:center;
        align-items:center;">Login</button>
      <button id="signupBtn" class="btn" type="button" data-i18n="auth.signupButton">
        Registrati
      </button>


      <div id="loginStatus" style="font-size:13px; min-height:18px;"></div>
    </div>
  </div>

   <div id="app-root" style="display:none;">
  <header>
    <div class="container" style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
    <button id="logoutBtn" class="btn" style="display:none;" data-i18n="auth.logoutButton">
          Logout
    </button>
      <h1>
  <img src="../assets/logo/mpt-logo.svg"
       alt="MacroPT Logo"
       style="height:100px; width:auto; vertical-align:middle; margin-right:8px;">
  <span data-i18n="header.title">Strumento Macro & Ricette</span>
</h1>

      <div class="actions">
        <label class="small muted" style="display:inline-flex; align-items:center; gap:6px; border:1px solid var(--border); padding:6px 8px; border-radius:8px;">
          <input type="checkbox" id="autoSyncTodayChk" />
          <span data-i18n="header.autoLoadToday">Auto carica menu del giorno</span>

        </label>

            <!-- BOTTONI LINGUA PLANNER -->
      <div class="lang-switch">
        <button
          type="button"
          id="plannerLangItBtn"
          class="btn-outline lang-btn"
          data-lang="it">
          IT
        </button>
        <button
          type="button"
          id="plannerLangEnBtn"
          class="btn-outline lang-btn"
          data-lang="en">
          EN
        </button>
      </div>
      <!-- FINE BOTTONI LINGUA -->
          <!-- MENU A TENDINA: Guida / Storico / Esporta / Importa -->
        <div class="dropdown" id="topMenuDropdown">
          <button
            type="button"
            class="btn-outline utility"
            id="topMenuBtn"
            aria-haspopup="menu"
            aria-expanded="false"
            title="Menu"
          >☰</button>

          <div class="dropdown-menu" id="topMenu" role="menu">
            <button class="dropdown-item" id="helpBtn" data-i18n="help.button">Guida</button>
            <button class="dropdown-item" id="historyBtn" data-i18n="header.history">Storico</button>
            <button class="dropdown-item" id="exportBtn" data-i18n="header.export">Esporta</button>

            <label class="dropdown-item" id="importLabelBtn" style="cursor:pointer;">
              <input type="file" id="importInput" accept="application/json" style="display:none;">
              <span data-i18n="header.import">Importa</span>
            </label>
          </div>
        </div>
        <!-- FINE MENU -->


        <div class="small muted" style="display:none; align-items:center; gap:6px; border:1px solid var(--border); padding:6px 8px; border-radius:8px;">
          <span data-i18n="header.dataUrlLabel" style="white-space:nowrap;">URL dati</span>
          <input id="recipesUrl" type="url" placeholder="Ricette.json" data-i18n-placeholder="header.recipesPlaceholder" style="width:320px;
           padding:6px 8px; border:1px solid var(--border); border-radius:8px;" />
          <button class="btn-outline" id="saveUrl" data-i18n="header.useButton">Usa</button>
          <button class="btn-outline" id="reloadData" data-i18n="header.reloadButton">Ricarica</button>
        </div>

      </div>
    </div>
  </header>

  <div class="container">
    <div class="row row-2">
      <div class="card">
        <h2 data-i18n="dailyTargets.title">Obiettivi giornalieri</h2>
        <div class="grid grid-4">
          <div>
            <label data-i18n="dailyTargets.carbs">Carboidrati (g)</label>

            <input type="text" inputmode="decimal" id="dailyC" value="330">
          </div>
          <div>
            <label data-i18n="dailyTargets.protein">Proteine (g)</label>
            <input type="text" inputmode="decimal" id="dailyP" value="170">
          </div>
          <div>
            <label data-i18n="dailyTargets.fat">Grassi (g)</label>
            <input type="text" inputmode="decimal" id="dailyF" value="70">
          </div>
          <div>
            <label data-i18n="dailyTargets.kcal">kcal totali (auto)</label>
            <input type="text" id="dailyKcal" readonly>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="section-title">
          <h2 data-i18n="mealSplit.title">Percentuali per pasto</h2>
          <div class="small muted" data-i18n="mealSplit.sumNote">
            La somma deve essere 100%
          </div>
        </div>
        <div class="grid grid-4">
          <div>
            <label data-i18n="mealSplit.breakfast">Colazione (%)</label>
            <input type="text" inputmode="decimal" id="pctBreakfast" value="25">
          </div>
          <div>
            <label data-i18n="mealSplit.lunch">Pranzo (%)</label>
            <input type="text" inputmode="decimal" id="pctLunch" value="35">
          </div>
          <div>
            <label data-i18n="mealSplit.snack">Spuntino (%)</label>
            <input type="text" inputmode="decimal" id="pctSnack" value="10">
          </div>
          <div>
            <label data-i18n="mealSplit.dinner">Cena (%)</label>
            <input type="text" inputmode="decimal" id="pctDinner" value="30">
          </div>
        </div>
        <div class="small" id="sumStatus" style="margin-top:6px;"></div>
      </div>
    </div>


<div class="row row-2" style="margin-top:12px;">
  
  <div class="card">
    <div class="section-title">
      <h2 data-i18n="recipes.title">Le tue ricette</h2>
      <div class="actions">
        <div class="small muted"
             style="display:flex; align-items:center; gap:6px; margin-right:8px;">
          <span data-i18n="recipes.viewLabel">Vista:</span>
          <button type="button"
                  id="viewListBtn"
                  class="btn-outline"
                  style="padding:2px 8px; font-size:12px; border-radius:999px;"
                  data-i18n="recipes.viewList">
            Lista
          </button>
          <button type="button"
                  id="viewCardsBtn"
                  class="btn-outline"
                  style="padding:2px 8px; font-size:12px; border-radius:999px;"
                  data-i18n="recipes.viewCategories">
            Categorie
          </button>
        </div>
        <button class="btn" id="newRecipeBtn" data-i18n="recipes.newRecipeButton">
           + Nuova ricetta
        </button>

      </div>
    </div>

<!-- Sticky bar: resta visibile mentre scrolli la pagina -->
<div class="recipes-stickybar">
  <button type="button"
          class="btn-outline"
          id="photoImportBtn"
          data-i18n="recipes.photoImport.button">
    Import from photo
  </button>

  <input id="photoImportInput"
         type="file"
         accept="image/*"
         capture="environment"
         style="display:none" />
</div>

    <div id="recipesList"></div>
  </div>

  <div class="card">
    <div class="section-title">
      <h2 data-i18n="meals.title">Pasti (oggi)</h2>
      <div class="actions">
        <button class="btn-outline" id="loadTodayBtn" data-i18n="meals.loadTodayButton">
         Carica menu di oggi
        </button>
      </div>
    </div>
    <div id="meals"></div>
  </div>

</div>


    <div class="card" style="margin-top:12px;">
      <div class="section-title">
        <h2 data-i18n="week.title">Planner Settimanale</h2>
        <div class="sticky-actions">
          <button class="btn" id="solveWeekBtn" data-i18n="week.solveAll">Ricalcola tutta la settimana</button>
          <button class="btn-outline" id="clearWeekBtn" data-i18n="week.clearAll">Pulisci settimana</button>
          <span class="tag" data-i18n="week.useSameTargets">Usa gli stessi target giornalieri</span>
        </div>
      </div>
      <div class="planner" id="planner"></div>
    </div>

    <div class="card" style="margin-top:12px;">
      <div class="section-title" style="gap:12px;">
        <h2 data-i18n="dailyTotals.title">Totali giornalieri vs Target</h2>
        <div class="small" style="display:flex; align-items:center; gap:6px;">
          <label for="tolInput" class="small muted" data-i18n="dailyTotals.toleranceLabel">Tolleranza</label>
          <input id="tolInput" type="number" min="0" max="50" step="0.5" style="width:80px; padding:6px 8px; border:1px solid var(--border); border-radius:8px;" />
          <span class="small muted">%</span>
        </div>
        <span id="dailyStatus" class="small muted"></span>
        <button class="btn-outline" id="saveDayBtn" data-i18n="dailyTotals.saveDay">Salva giornata</button>
      </div>
      <table class="table">
        <thead>
          <tr>
            <th></th>
             <th class="right" data-i18n="dailyTotals.colCarb">Carbo (g)</th>
             <th class="right" data-i18n="dailyTotals.colProt">Pro (g)</th>
             <th class="right" data-i18n="dailyTotals.colFat">Grassi (g)</th>
             <th class="right" data-i18n="dailyTotals.colKcal">kcal</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><b data-i18n="dailyTotals.target">Target</b></td>
            <td class="right" id="tgtC">-</td>
            <td class="right" id="tgtP">-</td>
            <td class="right" id="tgtF">-</td>
            <td class="right" id="tgtK">-</td>
          </tr>
          <tr>
            <td><b data-i18n="dailyTotals.obtained">Ottenuti</b></td>
            <td class="right" id="gotC">-</td>
            <td class="right" id="gotP">-</td>
            <td class="right" id="gotF">-</td>
            <td class="right" id="gotK">-</td>
          </tr>
          <tr>
            <td><b data-i18n="dailyTotals.delta">Δ (Ottenuti − Target)</b></td>
            <td class="right" id="diffC">-</td>
            <td class="right" id="diffP">-</td>
            <td class="right" id="diffF">-</td>
            <td class="right" id="diffK">-</td>
          </tr>
          <tr>
            <td class="kcalLabelCell">
                                 <i data-i18n="dailyTotals.kcalLabelInfo">kcal etichetta (info)</i>
                            </td>
            <td class="right kcalLabelCell">—</td>
            <td class="right kcalLabelCell">—</td>
            <td class="right kcalLabelCell">—</td>
            <td class="right kcalLabelCell" id="lblK">-</td>
          </tr>
          <tr>
            <td class="kcalLabelCell">
                                <i data-i18n="dailyTotals.kcalLabelDelta">Δ etichetta − teorico</i>
                            </td>
            <td class="right kcalLabelCell">—</td>
            <td class="right kcalLabelCell">—</td>
            <td class="right kcalLabelCell">—</td>
            <td class="right kcalLabelCell" id="lblDK">-</td>
          </tr>
        </tbody>
      </table>
      <div class="small muted" id="toleranceNote" style="margin-top:6px;"></div>
    </div>

    <div class="card" style="margin-top:12px;">
      <div class="section-title">
        <h2 data-i18n="shopping.title">Lista Spesa Settimanale</h2>
        <div class="actions">
          <button class="btn" id="genListBtn" data-i18n="shopping.generateButton">
  Genera/aggiorna
</button>
          <button class="btn-outline" id="exportCSVBtn" data-i18n="shopping.exportCsvButton">
                              Esporta CSV
                        </button>
        </div>
      </div>
      <div class="small muted" data-i18n="shopping.subtitle">
  Somma gli ingredienti di tutti i pasti pianificati (solo quelli con soluzione calcolata).
</div>
      <table class="table" id="shoppingTable">
        <thead>
          <tr>
                         <th data-i18n="shopping.headerIngredient">Ingrediente</th>
                         <th class="right" data-i18n="shopping.headerTotal">Totale (g)</th>
                         <th class="right" data-i18n="shopping.headerPerPack">(g) x conf</th>
                         <th class="right" data-i18n="shopping.headerNumPacks">N. Conf. (~)</th>

          </tr>
        </thead>
        <tbody id="shoppingBody">
          <tr>
                          <td colspan="4" class="small muted" data-i18n="shopping.emptyState">
                               Premi “Genera/aggiorna”.
                          </td>
                   </tr>

        </tbody>
      </table>
    </div>

<div class="card" style="margin-top:12px;">
  <ul class="small muted" style="margin:0; padding-left:18px;">
    <li data-i18n="shopping.note1">
      Valori ingredienti su 100 g (C/P/F); kcal = 4C + 4P + 9F.
    </li>
    <li data-i18n="shopping.note2">
      Puoi impostare per ogni ingrediente i <b>grammi di default</b> e se deve essere <b>fisso di default</b>;
      quando selezioni la ricetta nel pasto, queste quantità vengono applicate automaticamente
      (per liquidi considera 1 ml ≈ 1 g, se non diversamente indicato).
    </li>
    <li data-i18n="shopping.note3">
      Solver <b>strict matematica</b>: minimizza l’errore su C/P/F con pesi uguali (C = P = F). Calorie non vincolanti.
    </li>
    <li data-i18n="shopping.note4">
      Dati salvati in locale. Import/Export salva anche planner e archivio.
    </li>
    <li data-i18n="shopping.note5">
      Clicca il titolo ricetta per aprire/chiudere la composizione. Archivio ingredienti riutilizzabile.
    </li>
  </ul>
</div>

    
    <div class="card" style="margin-top:12px;" id="weightCard">
      <div class="section-title">
        <h2 data-i18n="weight.title">Andamento Peso</h2>
        <div class="actions">
     <input
                   id="pesoInput"
                   type="text"
                   placeholder="Peso (kg)"
                   data-i18n-placeholder="weight.inputLabel"
                   style="width:140px;"
               />

          <button class="btn" id="pesoAddBtn" data-i18n="weight.logButton">
  Registra peso
</button>
          <button class="btn-outline" id="pesoExportCsvBtn" data-i18n="weight.exportCsvButton">
                             Esporta CSV
                        </button>

        </div>
      </div>

      <div class="small muted" style="margin-bottom:8px;" data-i18n="weight.description">
                           I valori vengono salvati nel planner e inclusi nell'Export JSON (chiave <code>pesoLog</code>). Puoi modificare o cancellare ciascun dato in tabella.
                    </div>


     <div class="row">
  <div class="card" style="padding:8px;">
    <div class="peso-chart-wrapper">
      <canvas id="pesoChart"></canvas>
    </div>
    <div class="small muted" id="pesoDeltaNote" style="margin-top:6px;"></div>
  </div>
</div>


      <div style="margin-top:10px; overflow:auto;">
        <table class="table compact" id="pesoTable">
          <thead>
            <tr>
              <th data-i18n="weight.tableDate">Data</th>
              <th class="right" data-i18n="weight.tableValue">Peso (kg)</th>
              <th class="right" data-i18n="weight.tableActions">Azioni</th>
            </tr>
          </thead>
          <tbody>
                             <tr>
            <td colspan="3" class="small muted" data-i18n="weight.emptyState">
                                Nessun dato. Inserisci il tuo peso e premi “Registra peso”.
                            </td>
                            </tr>
          </tbody>
        </table>
      </div>
    </div>
</div>
  
  <div class="modal-backdrop" id="historyModal">
    <div class="modal">
      <header>
        <b data-i18n="history.title">Storico giornate</b>
        <div class="actions">
          <button class="btn-outline" id="exportHistoryBtn" data-i18n="history.exportCsvButton">
                              Esporta CSV
                       </button>
          <button class="btn-outline" id="clearHistoryBtn" style="color:var(--bad)" data-i18n="history.clear">Svuota</button>
          <button class="btn" id="closeHistoryBtn" data-i18n="history.close">Chiudi</button>
        </div>
      </header>
      <div class="content">
        <div class="small muted" style="margin-bottom:8px;" data-i18n="history.subtitle">Salva le giornate e confronta kcal teoriche vs kcal etichetta. Dati in locale.</div>
        <table class="table compact" id="historyTable">
          <thead>
            <tr>
              <th data-i18n="history.headerDate">Data</th>
              <th class="right" data-i18n="history.headerC">C (g)</th>
              <th class="right" data-i18n="history.headerP">P (g)</th>
              <th class="right" data-i18n="history.headerF">F (g)</th>
              <th class="right" data-i18n="history.headerKcalTheoretical">kcal teoriche</th>
              <th class="right kcalLabelCell" data-i18n="history.headerKcalLabel"><i>kcal etichetta</i></th>
              <th class="right kcalLabelCell" data-i18n="history.headerDelta"><i>Δ etichetta − teorico</i></th>
              <th data-i18n="history.headerNotes">Note</th>

            </tr>
          </thead>
          <tbody id="historyBody">
            <tr>
                                   <td colspan="8" class="small muted" data-i18n="history.emptyState">
                                      Nessuna giornata salvata.
                                  </td>
                          </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

<div class="modal-backdrop" id="photoImportModal" style="display:none;">
  <div class="modal">
    <header>
      <b data-i18n="recipes.photoImport.modalTitle">Import ingredient from photo</b>
      <div class="actions">
        <button class="btn" id="photoImportCloseBtn" data-i18n="recipes.photoImport.close">Close</button>
      </div>
    </header>

    <div class="content">
      <div class="small muted" data-i18n="recipes.photoImport.subtitle" style="margin-bottom:10px;">
        Upload a label photo: I’ll prepare a draft, then you confirm.
      </div>

      <div class="grid" style="grid-template-columns: 220px 1fr; gap:12px; align-items:start;">
        <div>
          <img id="photoImportPreview"
               alt="preview"
               style="width:100%; border:1px solid var(--border); border-radius:12px; display:none;" />
          <div id="photoImportNoPreview" class="small muted" data-i18n="recipes.photoImport.noPreview" style="margin-top:6px;">
            (No image selected)
          </div>
        </div>

        <div class="grid" style="grid-template-columns: 1fr 1fr 1fr 1fr; gap:10px;">
          <div style="grid-column: 1 / -1;">
            <label data-i18n="recipes.photoImport.nameLabel">Ingredient name</label>
            <input id="photoImportName" type="text" />
          </div>

          <div>
            <label data-i18n="recipes.photoImport.carbs100">Carbs (100g)</label>
            <input id="photoImportC" type="text" inputmode="decimal" placeholder="0" />
          </div>
          <div>
            <label data-i18n="recipes.photoImport.protein100">Protein (100g)</label>
            <input id="photoImportP" type="text" inputmode="decimal" placeholder="0" />
          </div>
          <div>
            <label data-i18n="recipes.photoImport.fat100">Fat (100g)</label>
            <input id="photoImportF" type="text" inputmode="decimal" placeholder="0" />
          </div>
          <div>
            <label data-i18n="recipes.photoImport.kcalLabel100">Label kcal (100g)</label>
            <input id="photoImportKcal" type="text" inputmode="decimal" placeholder="" />
          </div>

          <div style="grid-column: 1 / -1; display:flex; gap:8px; justify-content:flex-end; margin-top:6px;">
            <button class="btn-outline" id="photoImportPickBtn" data-i18n="recipes.photoImport.pickImage">Choose photo</button>
            <button class="btn" id="photoImportConfirmBtn" data-i18n="recipes.photoImport.confirm">Create ingredient</button>
          </div>

          <div id="photoImportErr" class="small" style="color:var(--bad); grid-column: 1 / -1; display:none;"></div>
        </div>
      </div>
    </div>
  </div>
</div>


<script>
// ==== STEP 2 – i18n core per il PLANNER ====
// Nota: usiamo solo il ramo "planner" dei JSON, la landing resta com'è.

const MPT_LANG_STORAGE_KEY = "mpt_lang";

// Stato lingua globale per il planner
window.MPT_I18N = {
  lang: "it",
  data: null      // qui metteremo PLANNER-ONLY: json.planner
};

// Legge la lingua corrente da localStorage, fallback "it"
function getCurrentLang() {
  try {
    const stored = localStorage.getItem(MPT_LANG_STORAGE_KEY);
    if (stored === "it" || stored === "en") return stored;
  } catch (e) {
    console.warn("Errore leggendo lingua da localStorage:", e);
  }
  return "it";
}

// Salva la lingua in localStorage e aggiorna lo stato in memoria
function setCurrentLang(lang) {
  if (lang !== "it" && lang !== "en") return;
  try {
    localStorage.setItem(MPT_LANG_STORAGE_KEY, lang);
  } catch (e) {
    console.warn("Errore salvando lingua in localStorage:", e);
  }
  if (!window.MPT_I18N) window.MPT_I18N = { lang: lang, data: null };
  window.MPT_I18N.lang = lang;
}

// Carica dal server il JSON della lingua e isola il ramo "planner"
async function loadPlannerTranslations(lang) {
  const code = lang || getCurrentLang();

  // /app/index.html → percorso ASSOLUTO a /lang/
  const res = await fetch(`/lang/lang-${code}.json`, { cache: "no-store" });
  const json = await res.json();

  const plannerDict = json && json.planner ? json.planner : {};

  window.MPT_I18N = {
    lang: code,
    data: plannerDict
  };

  return plannerDict;
}

// Helper: garantisce che le traduzioni per la lingua corrente siano caricate
async function ensurePlannerTranslations(forceLang) {
  const desired = forceLang || getCurrentLang();

  if (!window.MPT_I18N) {
    window.MPT_I18N = { lang: desired, data: null };
  }

  // Se non ho dati O la lingua caricata è diversa da quella desiderata → ricarico
  if (!window.MPT_I18N.data || window.MPT_I18N.lang !== desired) {
    return loadPlannerTranslations(desired);
  }

  return window.MPT_I18N.data;
}

// Funzione di traduzione:
//   t("auth.title")
//   t("auth.statusConnectedAs", { email: "x@y.com" })
function t(key, params) {
  const dict = (window.MPT_I18N && window.MPT_I18N.data) || null;
  if (!dict || !key) return key;

  const parts = String(key).split(".");
  let node = dict;

  for (let i = 0; i < parts.length; i++) {
    const p = parts[i];
    if (!node || typeof node !== "object" || !(p in node)) {
      return key; // chiave non trovata → meglio mostrare la chiave che nulla
    }
    node = node[p];
  }

  if (typeof node !== "string") return key;

  if (!params) return node;

  // Sostituzione placeholder {nome}
  return node.replace(/\{(\w+)\}/g, function (match, name) {
    if (params && Object.prototype.hasOwnProperty.call(params, name)) {
      return String(params[name]);
    }
    return match; // se manca il parametro, lascio il placeholder intero
  });
}

// Placeholder per lo STEP 3: qui andrà la logica che aggiorna l'HTML
function applyPlannerTranslationsToDom() {
  const dict = window.MPT_I18N && window.MPT_I18N.data;
  if (!dict) {
    console.warn("applyPlannerTranslationsToDom chiamata senza dizionario pronto");
    return;
  }

  // Testi statici (label, button, span, ecc.)
  document.querySelectorAll("[data-i18n]").forEach(function (el) {
    const key = el.getAttribute("data-i18n");
    if (!key) return;
    const translated = t(key);
    if (!translated || typeof translated !== "string") return;
    el.textContent = translated;
  });



  // Contenuto HTML controllato (per piccole guide/listine)
  document.querySelectorAll("[data-i18n-html]").forEach(function (el) {
    const key = el.getAttribute("data-i18n-html");
    if (!key) return;
    const translated = t(key);
    if (!translated || typeof translated !== "string") return;
    el.innerHTML = translated;
  });
  // Placeholder degli input
  document.querySelectorAll("[data-i18n-placeholder]").forEach(function (el) {
    const key = el.getAttribute("data-i18n-placeholder");
    if (!key) return;
    const translated = t(key);
    if (!translated || typeof translated !== "string") return;
    el.setAttribute("placeholder", translated);
  });
}

// Aggiorna lo stato "active" dei bottoni lingua nel planner
function updatePlannerLangButtonsActiveState(lang) {
  const current = lang || (window.MPT_I18N && window.MPT_I18N.lang) || getCurrentLang();
  const itBtn = document.getElementById("plannerLangItBtn");
  const enBtn = document.getElementById("plannerLangEnBtn");

  if (itBtn) {
    if (current === "it") {
      itBtn.classList.add("active");
    } else {
      itBtn.classList.remove("active");
    }
  }
  if (enBtn) {
    if (current === "en") {
      enBtn.classList.add("active");
    } else {
      enBtn.classList.remove("active");
    }
  }
}

// Cambia lingua del planner a runtime (e salva preferenza)
 // Cambia lingua del planner a runtime (e salva preferenza)
async function changePlannerLanguage(lang) {
  if (lang !== "it" && lang !== "en") return;

  setCurrentLang(lang);

  try {
    // carica dizionario della lingua scelta
    await loadPlannerTranslations(lang);

    // stato bottoni lingua
    updatePlannerLangButtonsActiveState(lang);

    // rerender totale (ordinato e consistente)
    await rerenderAllPlannerUi(lang);

  } catch (e) {
    console.error("Errore cambiando lingua del planner:", e);
  }
}

 async function rerenderAllPlannerUi(forceLang){
  // 1) traduzioni garantite (per la lingua corretta)
  if (typeof ensurePlannerTranslations === "function") {
    await ensurePlannerTranslations(forceLang);
  }

  // 2) traduzioni statiche / data-i18n
  if (typeof applyPlannerTranslationsToDom === "function") {
    applyPlannerTranslationsToDom();
  }

  // 3) render dinamici
  if (typeof renderMeals === "function") renderMeals();
  if (typeof window.renderPercStatus === "function") window.renderPercStatus();
  if (typeof renderDailyTotals === "function") renderDailyTotals();
  if (typeof renderPlanner === "function") renderPlanner();
  if (typeof renderRecipes === "function") renderRecipes();

  // 4) peso
  if (typeof window.__pesoInit === "function") window.__pesoInit();

  // 5) passata finale
  if (typeof applyPlannerTranslationsToDom === "function") {
    applyPlannerTranslationsToDom();
  }
}



// Aggancio click sui bottoni lingua del planner
const plannerLangItBtn = document.getElementById("plannerLangItBtn");
const plannerLangEnBtn = document.getElementById("plannerLangEnBtn");

if (plannerLangItBtn) {
  plannerLangItBtn.addEventListener("click", function () {
    changePlannerLanguage("it");
  });
}
if (plannerLangEnBtn) {
  plannerLangEnBtn.addEventListener("click", function () {
    changePlannerLanguage("en");
  });
}


// Inizializza le traduzioni del planner all'avvio
(async function initPlannerI18n() {
  try {
    await rerenderAllPlannerUi();
    updatePlannerLangButtonsActiveState(window.MPT_I18N && window.MPT_I18N.lang);
  } catch (e) {
    console.error("Errore inizializzando le traduzioni del planner:", e);
  }
})();
// Help drawer wiring
document.addEventListener("DOMContentLoaded", function () {
  const btn = document.getElementById("helpBtn");
  const drawer = document.getElementById("helpDrawer");
  const overlay = document.getElementById("helpOverlay");
  const closeBtn = document.getElementById("helpCloseBtn");

  function openHelp(){
    if (!drawer || !overlay) return;
    drawer.classList.add("open");
    overlay.classList.add("open");
    drawer.setAttribute("aria-hidden","false");
    overlay.setAttribute("aria-hidden","false");
  }
  function closeHelp(){
    if (!drawer || !overlay) return;
    drawer.classList.remove("open");
    overlay.classList.remove("open");
    drawer.setAttribute("aria-hidden","true");
    overlay.setAttribute("aria-hidden","true");
  }

  if (btn) btn.addEventListener("click", openHelp);
  if (closeBtn) closeBtn.addEventListener("click", closeHelp);
  if (overlay) overlay.addEventListener("click", closeHelp);
  document.addEventListener("keydown", function(e){
    if (e.key === "Escape") closeHelp();
  });

  // Top-right dropdown menu (Guida/Storico/Esporta/Importa)
  const menuWrap = document.getElementById("topMenuDropdown");
  const menuBtn  = document.getElementById("topMenuBtn");

  function closeTopMenu(){
    if (!menuWrap || !menuBtn) return;
    menuWrap.classList.remove("open");
    menuBtn.setAttribute("aria-expanded","false");
  }
  function toggleTopMenu(){
    if (!menuWrap || !menuBtn) return;
    const isOpen = menuWrap.classList.toggle("open");
    menuBtn.setAttribute("aria-expanded", isOpen ? "true" : "false");
  }

  if (menuWrap && menuBtn){
    menuBtn.addEventListener("click", function(e){
      e.stopPropagation();
      toggleTopMenu();
    });

    document.addEventListener("click", function(){
      closeTopMenu();
    });

    document.addEventListener("keydown", function(e){
      if (e.key === "Escape") closeTopMenu();
    });

    // chiudi menu quando clicchi una voce
    ["helpBtn","historyBtn","exportBtn","importLabelBtn"].forEach(function(id){
      const el = document.getElementById(id);
      if (el) el.addEventListener("click", function(){ closeTopMenu(); });
    });
  }


  // Accordion
  document.querySelectorAll(".help-acc-btn").forEach(function(b){
    b.addEventListener("click", function(){
      const id = b.getAttribute("data-acc");
      const panel = id ? document.getElementById(id) : null;
      if (!panel) return;
      const isOpen = panel.classList.contains("open");
      // close others
      document.querySelectorAll(".help-acc-panel.open").forEach(function(p){
        if (p !== panel) p.classList.remove("open");
      });
      // toggle
      panel.classList.toggle("open", !isOpen);
    });
  });

  // Expose close for other code if needed
  window.__closeHelpDrawer = closeHelp;
});

</script>

<script>
(function(){
  const STORAGE_KEY = "macro-recipe-tool-html-v7";

  // Gancio neutro: il planner lo chiama SEMPRE, Supabase si aggancia qui se esiste
  function scheduleRemoteSave(){
    try {
      if (typeof window.__plannerRemoteSave === "function") {
        window.__plannerRemoteSave();
      }
    } catch(e){
      console.warn("Errore nel gancio di salvataggio remoto:", e);
    }
  }

  const $ = (id) => document.getElementById(id);
  // === Remote JSON support (Dana patch) ===
function hydrateFromJson(data){
  try {
    if (data && data.daily && data.perc && data.recipes){
      Object.assign(state, data);  // ✅ aggiorna lo stesso oggetto state
            // Ricostruisci / usa archivio ingredienti solo se non è vuoto
      if (Array.isArray(data.ingredientLibrary) && data.ingredientLibrary.length > 0) {
        state.ingredientLibrary = data.ingredientLibrary;
      } else if (Array.isArray(state.ingredientLibrary) && state.ingredientLibrary.length > 0) {
        // lascio quello che c'è già
      } else {
        state.ingredientLibrary = buildLibraryFromRecipes(state.recipes);
      }
      if (!data.weekPlan){
        state.weekPlan = JSON.parse(JSON.stringify(state.weekPlan));
      }
      Object.keys(state.meals).forEach(k=>{ state.meals[k].fixed = state.meals[k].fixed || {}; });
      dailyC.value = state.daily.c; dailyP.value = state.daily.p; dailyF.value = state.daily.f;
      dailyKcal.value = fmt(kcal(state.daily),0);
      pctBreakfast.value = state.perc.breakfast; pctLunch.value = state.perc.lunch; pctSnack.value = state.perc.snack; pctDinner.value = state.perc.dinner;
       } else {
      alert(t("alerts.remoteJsonInvalid"));
    }
  } catch(err){
     alert(t("alerts.remoteJsonUseError"));  }
}

  const RECIPES_URL_KEY = "recipesUrl";
  const defaultUrl = ''; // caricamento remoto disattivato (niente più Ricette.json su Netlify)
  let DATA_URL = (localStorage.getItem(RECIPES_URL_KEY)||'').trim() || defaultUrl;

  async function loadRemote(url = DATA_URL){
    try{
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const json = await res.json();
      hydrateFromJson(json);
    } catch(e){
      console.warn("Remote load failed:", e);
      alert(t("alerts.remoteJsonDownloadError"));
    }
  }

  const toNum = (v)=>{ if(v==null) return 0; if(typeof v==='string') v=v.replace(',', '.'); const n=parseFloat(v); return isFinite(n)?n:0; };
  const clamp = (x, lo=0, hi=Infinity) => Math.min(Math.max(toNum(x), lo), hi);
  const kcal = (m) => 4*m.c + 4*m.p + 9*m.f;
  const kcalLabel100 = (per100) => {
    try {
      const v = toNum(per100 && per100.kcalLabel);
      const auto = 4*(per100?.c||0) + 4*(per100?.p||0) + 9*(per100?.f||0);
      return (isFinite(v) && v>0) ? v : auto;
    } catch(e){ return 4*(per100?.c||0) + 4*(per100?.p||0) + 9*(per100?.f||0); }
  };
  
  function getFixedDefaultForMeal(ing, mealKey){
    try{
      if (ing && ing.perMeal && ing.perMeal[mealKey]){
        const ov = ing.perMeal[mealKey];
        const g = (typeof ov.defaultQty!=="undefined") ? parseFloat(String(ov.defaultQty).replace(",", ".")) : NaN;
        if (ov.defaultFixed && isFinite(g) && g>=0) return { g, fixed:true };
      }
    }catch(e){}
    try{
      const g = (typeof ing.defaultQty!=="undefined") ? parseFloat(String(ing.defaultQty).replace(",", ".")) : NaN;
      if (ing.defaultFixed && isFinite(g) && g>=0) return { g, fixed:true };
    }catch(e){}
    return null;
  }
const fmt = (n, d=1) => (isFinite(n) ? Number(n).toFixed(d) : "-");
  const uid = () => Math.random().toString(36).slice(2);
  function getTol(){ try { return (state && typeof state.tolerance === "number") ? state.tolerance : 0.05; } catch(e){ return 0.05; } }
  function getTolPct(){ return Math.round(getTol()*1000)/10; }
  function getMealTol(mealKey){ try { const t = state.meals[mealKey]?.tol; return (typeof t==="number") ? t : getTol(); } catch(e){ return getTol(); } }
  function getMealTolPct(mealKey){ return Math.round(getMealTol(mealKey)*1000)/10; }
  const tol = 0.05; // legacy default, unused directly

  let changeTimer=null;
  function scheduleRecalc(){ clearTimeout(changeTimer); changeTimer=setTimeout(()=>{ autoSolveUnlocked(); renderMeals(); renderDailyTotals(); }, 200); }

  const dayDefs = [
    { key:"mon", label:"Lunedì" },
    { key:"tue", label:"Martedì" },
    { key:"wed", label:"Mercoledì" },
    { key:"thu", label:"Giovedì" },
    { key:"fri", label:"Venerdì" },
    { key:"sat", label:"Sabato" },
    { key:"sun", label:"Domenica" },
  ];
  const mealKeys = ["breakfast","lunch","snack","dinner"];
  const mealLabels = { breakfast:"Colazione", lunch:"Pranzo", snack:"Spuntino", dinner:"Cena" };

  let state = { autoSyncToday: true,
    dynamicTargetsByDay: {},
    daily: { c:300, p:150, f:70 },
    perc: { breakfast:30, lunch:35, snack:10, dinner:25 },
    recipeViewMode: "list", 
    recipes: [],
    ingredientLibrary: [],
    meals: {
      breakfast: { recipeId:null, locked:false, solution:null, fixed:{} },
      lunch: { recipeId:null, locked:false, solution:null, fixed:{} },
      snack: { recipeId:null, locked:false, solution:null, fixed:{} },
      dinner: { recipeId:null, locked:false, solution:null, fixed:{} },
    },
    weekPlan: {
      mon:{ breakfast:{recipeId:null, solution:null}, lunch:{recipeId:null, solution:null}, snack:{recipeId:null, solution:null}, dinner:{recipeId:null, solution:null} },
      tue:{ breakfast:{recipeId:null, solution:null}, lunch:{recipeId:null, solution:null}, snack:{recipeId:null, solution:null}, dinner:{recipeId:null, solution:null} },
      wed:{ breakfast:{recipeId:null, solution:null}, lunch:{recipeId:null, solution:null}, snack:{recipeId:null, solution:null}, dinner:{recipeId:null, solution:null} },
      thu:{ breakfast:{recipeId:null, solution:null}, lunch:{recipeId:null, solution:null}, snack:{recipeId:null, solution:null}, dinner:{recipeId:null, solution:null} },
      fri:{ breakfast:{recipeId:null, solution:null}, lunch:{recipeId:null, solution:null}, snack:{recipeId:null, solution:null}, dinner:{recipeId:null, solution:null} },
      sat:{ breakfast:{recipeId:null, solution:null}, lunch:{recipeId:null, solution:null}, snack:{recipeId:null, solution:null}, dinner:{recipeId:null, solution:null} },
      sun:{ breakfast:{recipeId:null, solution:null}, lunch:{recipeId:null, solution:null}, snack:{recipeId:null, solution:null}, dinner:{recipeId:null, solution:null} },
    }
  };
window.state = state;
// --- Helper weekPlan: garantisce che ogni giorno abbia sempre i 4 pasti ---
function ensureWeekPlanDay(dayKey){
  if (!state.weekPlan || typeof state.weekPlan !== "object"){
    state.weekPlan = {};
  }

  const existing = state.weekPlan[dayKey];
  if (existing && typeof existing === "object") return existing;

  const emptyDay = {
    breakfast: { recipeId: null, solution: null },
    lunch:     { recipeId: null, solution: null },
    snack:     { recipeId: null, solution: null },
    dinner:    { recipeId: null, solution: null },
  };

  state.weekPlan[dayKey] = emptyDay;
  return emptyDay;
}

window.renderRecipes = renderRecipes;
window.renderMeals = renderMeals;
window.renderPlanner = renderPlanner;
window.renderDailyTotals = renderDailyTotals;
window.syncMealsFromPlanner = syncMealsFromPlanner;



try {
  const rawV7 = localStorage.getItem(STORAGE_KEY);
  if (rawV7) {
    const loaded = JSON.parse(rawV7);
    Object.assign(state, loaded);

    // Se l'archivio ingredienti è mancante o vuoto, ricostruiscilo dalle ricette
    if (!Array.isArray(state.ingredientLibrary) || state.ingredientLibrary.length === 0) {
      state.ingredientLibrary = buildLibraryFromRecipes(state.recipes);
    }
  } else {
    const rawPrev =
      localStorage.getItem("macro-recipe-tool-html-v6") ||
      localStorage.getItem("macro-recipe-tool-html-v4");
    if (rawPrev) {
      const s = JSON.parse(rawPrev);
      state.daily = s.daily || state.daily;
      state.perc = s.perc || state.perc;
      state.recipes = s.recipes || [];
      state.meals = s.meals || state.meals;

      // Anche qui: se l'archivio è vuoto, ricostruisci dalle ricette
      if (Array.isArray(s.ingredientLibrary) && s.ingredientLibrary.length > 0) {
        state.ingredientLibrary = s.ingredientLibrary;
      } else {
        state.ingredientLibrary = buildLibraryFromRecipes(state.recipes);
      }
    }
  }
} catch (e) {}

function normalizeRecipesAllowedMeals(){
  try{
    (state.recipes||[]).forEach(r=>{
      if (!r.allowedMeals){
        r.allowedMeals = { breakfast:true, lunch:true, snack:true, dinner:true };
      } else {
        // ensure all keys exist (backward compatibility)
        r.allowedMeals.breakfast = !!r.allowedMeals.breakfast;
        r.allowedMeals.lunch = !!r.allowedMeals.lunch;
        r.allowedMeals.snack = !!r.allowedMeals.snack;
        r.allowedMeals.dinner = !!r.allowedMeals.dinner;
      }
      // default descrizione (backward compatibility)
      if (typeof r.description !== "string") {
        r.description = "";
      }
    });
  }catch(e){}
}
normalizeRecipesAllowedMeals();
function buildLibraryFromRecipes(recs){
    const map = new Map();
    (recs||[]).forEach(r => (r.ingredients||[]).forEach(ing => {
      const key = (ing.name||"").toLowerCase().trim();
      if (!map.has(key)) map.set(key, { id: uid(), name: ing.name, per100: {...ing.per100} });
    }));
    return Array.from(map.values());
  }

  function save(){
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch(e){
      console.warn("Errore salvando in localStorage:", e);
    }
    // Avvisa eventualmente il modulo remoto (Supabase)
    scheduleRemoteSave();
  }

  const dailyC = $("dailyC"), dailyP = $("dailyP"), dailyF = $("dailyF"), dailyKcal = $("dailyKcal");
function updateDailyFromInputs(){
  state.daily.c = clamp(dailyC.value, 0, 9999);
  state.daily.p = clamp(dailyP.value, 0, 9999);
  state.daily.f = clamp(dailyF.value, 0, 9999);

  dailyKcal.value = fmt(kcal(state.daily), 0);

  // Salva in localStorage
  save();

  // Salva (debounced) i settings su Supabase
  scheduleSaveSettings();

  try {
    if (state.dynamicTargetsByDay && state.dynamicTargetsByDay[selectedDayKey]) {
      delete state.dynamicTargetsByDay[selectedDayKey];
    }
  } catch (e) {}

  autoSolveUnlocked();
  renderMeals();
  renderDailyTotals();
  renderPlanner();
}
  dailyC.value = state.daily.c; dailyP.value = state.daily.p; dailyF.value = state.daily.f;
  dailyKcal.value = fmt(kcal(state.daily),0);
  [dailyC,dailyP,dailyF].forEach(inp => inp.addEventListener("input", updateDailyFromInputs));

  const pctBreakfast = $("pctBreakfast"), pctLunch = $("pctLunch"), pctSnack = $("pctSnack"), pctDinner = $("pctDinner"), sumStatus = $("sumStatus");
 function updatePercFromInputs(){
  state.perc.breakfast = clamp(pctBreakfast.value, 0, 100);
  state.perc.lunch     = clamp(pctLunch.value,     0, 100);
  state.perc.snack     = clamp(pctSnack.value,     0, 100);
  state.perc.dinner    = clamp(pctDinner.value,    0, 100);

  // Salva locale
  save();

  // Salva (debounced) su Supabase
  scheduleSaveSettings();

  autoSolveUnlocked();
  renderMeals();
  renderPercStatus();
  renderDailyTotals();
  renderPlanner();
}

  pctBreakfast.value = state.perc.breakfast; pctLunch.value = state.perc.lunch; pctSnack.value = state.perc.snack; pctDinner.value = state.perc.dinner;
  [pctBreakfast,pctLunch,pctSnack,pctDinner].forEach(inp => inp.addEventListener("input", updatePercFromInputs));
    function renderPercStatus(){
    const doRender = () => {
      const s = state.perc.breakfast + state.perc.lunch + state.perc.snack + state.perc.dinner;
      const sumLabel   = t("mealSplit.sumLabel", { value: fmt(s,2) });
      const okText     = t("mealSplit.sumOk");
      const mustBe100  = t("mealSplit.sumMustBe100");
      const statusHtml = (s === 100)
        ? `<span class="pill ok">${okText}</span>`
        : `<span class="pill bad">${mustBe100}</span>`;
      sumStatus.innerHTML = `${sumLabel} ${statusHtml}`;
    };

    // Se le traduzioni non sono pronte, le carico e poi renderizzo
    if (!window.MPT_I18N || !window.MPT_I18N.data) {
      if (typeof ensurePlannerTranslations === "function") {
        ensurePlannerTranslations().then(doRender).catch(doRender);
        return;
      }
    }
    doRender();
  }

     window.renderPercStatus = renderPercStatus;

  function baseTargetFor(mealKey){
    return {
      c: state.daily.c * (state.perc[mealKey]||0) / 100,
      p: state.daily.p * (state.perc[mealKey]||0) / 100,
      f: state.daily.f * (state.perc[mealKey]||0) / 100,
    };
  }
  function targetFor(mealKey){
    try{
      const day = selectedDayKey;
      const dyn = state.dynamicTargetsByDay && state.dynamicTargetsByDay[day] && state.dynamicTargetsByDay[day][mealKey];
      if (dyn && typeof dyn.c==='number') return {c:dyn.c, p:dyn.p, f:dyn.f};
    }catch(e){}
    return baseTargetFor(mealKey);
  }
  
function solveGrams(ingredients, target){
  // STRICT math: equal weights C=P=F, ignore kcal in solver.
  const k = ingredients.length;
  if (!k) return {};
  // Build per-gram matrix (3 x k)
  const M = [
    ingredients.map(i => (i.per100.c||0)/100),
    ingredients.map(i => (i.per100.p||0)/100),
    ingredients.map(i => (i.per100.f||0)/100),
  ];
  const b = [target.c||0, target.p||0, target.f||0];

  // Active-set NNLS (very small, robust)
  function matVec(M,x){
    const y=[0,0,0];
    for(let i=0;i<3;i++){
      let s=0; for(let j=0;j<k;j++) s += M[i][j]*x[j];
      y[i]=s;
    }
    return y;
  }
  function normalEq(idx){
    const n = idx.length;
    const AtA = Array.from({length:n},_=>Array(n).fill(0));
    const Atb = Array(n).fill(0);
    for(let i=0;i<3;i++){
      for(let a=0;a<n;a++){
        const ja = idx[a];
        const Mia = M[i][ja];
        Atb[a] += Mia*b[i];
        for(let c=0;c<n;c++){
          const jc = idx[c];
          AtA[a][c] += Mia*M[i][jc];
        }
      }
    }
    // Cholesky
    const L = Array.from({length:n},_=>Array(n).fill(0));
    for(let i=0;i<n;i++){
      for(let j=0;j<=i;j++){
        let s=AtA[i][j];
        for(let t=0;t<j;t++) s -= L[i][t]*L[j][t];
        if(i===j) L[i][j]=Math.sqrt(Math.max(s,1e-12));
        else L[i][j]=s/L[j][j];
      }
    }
    // solve
    const y = Array(n).fill(0);
    for(let i=0;i<n;i++){ let s=Atb[i]; for(let t=0;t<i;t++) s -= L[i][t]*y[t]; y[i]=s/L[i][i]; }
    const x = Array(n).fill(0);
    for(let i=n-1;i>=0;i--){ let s=y[i]; for(let t=i+1;t<n;t++) s -= L[t][i]*x[t]; x[i]=s/L[i][i]; }
    return x;
  }

  let active = []; // indices with positive solution
  let passive = Array.from({length:k},(_,j)=>j); // start with all in passive
  let x = Array(k).fill(0);

  while(true){
    // choose variable with highest correlation
    const r = b.map((bi,i)=> bi - matVec(M,x)[i]);
    const w = passive.map(j => M[0][j]*r[0] + M[1][j]*r[1] + M[2][j]*r[2]);
    let best = -1, maxw = -1e9;
    for(let p=0;p<passive.length;p++){ if(w[p]>maxw){maxw=w[p]; best=p;} }
    if (maxw<=1e-10 || best<0) break;
    active.push(passive[best]);
    passive.splice(best,1);

    // solve LS on active
    while(true){
      const xa = normalEq(active);
      let neg = false, alpha = 1;
      const xCand = Array(k).fill(0);
      active.forEach((j,i)=> xCand[j]=xa[i]);
      for (const j of active){
        if (xCand[j] <= 0){
          alpha = Math.min(alpha, x[j] / (x[j] - (xCand[j]||0)));
          neg = true;
        }
      }
      if (!neg){ x = xCand; break; }
      for (let j=0;j<k;j++) x[j] = x[j] + alpha*((xCand[j]||0) - x[j]);
      active = active.filter(j => x[j] > 1e-12);
      passive = Array.from({length:k},(_,j)=>j).filter(j => !active.includes(j));
    }
  }

  // Small conservative rescale to reduce residual
  const y = matVec(M,x);
  const sC = b[0]/Math.max(y[0],1e-9);
  const sP = b[1]/Math.max(y[1],1e-9);
  const sF = b[2]/Math.max(y[2],1e-9);
  const s = Math.max( Math.min(sC,sP), Math.min(sP,sF) );
  x = x.map(v => Math.max(0, v*s));

  const grams = {};
  ingredients.forEach((ing,j)=> grams[ing.id] = Math.round(x[j]*10)/10);
  return grams;
}

  function sumMacros(ingredients, grams){
    return ingredients.reduce((acc, ing)=>{
      const g = grams[ing.id] || 0;
      acc.c += (ing.per100.c/100)*g;
      acc.p += (ing.per100.p/100)*g;
      acc.f += (ing.per100.f/100)*g;
      return acc;
    }, {c:0,p:0,f:0});
  }


function __split_v8_target(mealKey, mode, slot){
  try{
    const st = state.meals[mealKey];
    if (!st || !st.split_v8) return {c:0,p:0,f:0};

    const base  = targetFor(mealKey) || {c:0,p:0,f:0};
    const split = st.split_v8;
    const m     = mode || split.mode || 'percent';

    // Determino se sto lavorando sul PRIMO o sul SECONDO
    let slotKey = 'primo';
    if (slot === split.secondo) slotKey = 'secondo';
    else if (slot === split.primo) slotKey = 'primo';

    const currentSlot = split[slotKey] || {};

    // 1) Manuale: usa direttamente C/P/F digitati a mano
    if (m === 'manual'){
      return {
        c: +(currentSlot.manual && currentSlot.manual.C || 0),
        p: +(currentSlot.manual && currentSlot.manual.P || 0),
        f: +(currentSlot.manual && currentSlot.manual.F || 0)
      };
    }

    // 2) Percentuale: come prima, ma leggendo dal relativo slot
    if (m === 'percent'){
      const P = currentSlot.percent || {C:0,P:0,F:0};
      return {
        c: (base.c||0) * (+(P.C||0))/100,
        p: (base.p||0) * (+(P.P||0))/100,
        f: (base.f||0) * (+(P.F||0))/100
      };
    }

    // 3) AUTO: il Secondo è fisso (es. banana, frutta, dolce ecc.),
    //          il Primo si adatta ai macro residui del pasto
    if (m === 'auto'){
      function macrosSecondoDefault(){
        const s2 = split.secondo || {};
        if (!s2.recipeId) return {c:0,p:0,f:0};
        const rec2 = state.recipes.find(r => r.id === s2.recipeId);
        if (!rec2 || !(rec2.ingredients||[]).length) return {c:0,p:0,f:0};

        const grams2 = {};
        (rec2.ingredients||[]).forEach(ing=>{
          let g = 0;
          try{
            // priorità: perMeal[mealKey].defaultQty se presente
            if (ing.perMeal && ing.perMeal[mealKey] && typeof ing.perMeal[mealKey].defaultQty !== 'undefined'){
              g = Number(String(ing.perMeal[mealKey].defaultQty).replace(',', '.')) || 0;
            } else if (typeof ing.defaultQty !== 'undefined'){
              g = Number(String(ing.defaultQty).replace(',', '.')) || 0;
            }
          }catch(e){}
          if (g > 0){
            grams2[ing.id] = g;
          }
        });

        return sumMacros(rec2.ingredients, grams2);
      }

      const mac2 = macrosSecondoDefault();

      if (slotKey === 'secondo'){
        // Il secondo è il pezzo fisso: target = macro reali della banana (o altra ricetta fissa)
        return {
          c: mac2.c || 0,
          p: mac2.p || 0,
          f: mac2.f || 0
        };
      } else {
        // Il primo si adatta: target = target pasto - macro secondo
        return {
          c: Math.max(0, (base.c||0) - (mac2.c||0)),
          p: Math.max(0, (base.p||0) - (mac2.p||0)),
          f: Math.max(0, (base.f||0) - (mac2.f||0))
        };
      }
    }

    // Fallback di sicurezza
    return {c:0,p:0,f:0};
  }catch(e){
    console.error(e);
    return {c:0,p:0,f:0};
  }
}


function __split_v8_solve(mealKey, rec, tgt){
  try{
    if (!rec || !(rec.ingredients||[]).length) return { grams:{}, achieved:{c:0,p:0,f:0} };
    const st = state.meals[mealKey];
    if (!st) return { grams:{}, achieved:{c:0,p:0,f:0} };

    // Inizializza i fixed per questo pasto/ricetta, se non presenti
    st.fixed = st.fixed || {};
    if (rec && rec.ingredients){
      rec.ingredients.forEach(ing=>{
        if (!st.fixed[ing.id] || !st.fixed[ing.id].fixed){
          const ov = getFixedDefaultForMeal(ing, mealKey);
          if (ov){ st.fixed[ing.id] = ov; }
        }
      });
    }

    const fx = (st.fixed || {});
    const fixedIds = rec.ingredients.map(x=>x.id).filter(id=>fx[id] && fx[id].fixed);
    const fixedIngs = rec.ingredients.filter(ing => fixedIds.includes(ing.id));
    const freeIngs  = rec.ingredients.filter(ing => !fixedIds.includes(ing.id));

    const fixedGrams = {};
    fixedIngs.forEach(ing => {
      const g = fx[ing.id] && typeof fx[ing.id].g !== "undefined" ? toNum(fx[ing.id].g) : 0;
      fixedGrams[ing.id] = Math.max(0, g);
    });
    const fixedMacros = sumMacros(fixedIngs, fixedGrams);

    // Target aggiustato per i soli ingredienti liberi
    const adjTarget = {
      c: Math.max(0, (tgt.c || 0) - (fixedMacros.c || 0)),
      p: Math.max(0, (tgt.p || 0) - (fixedMacros.p || 0)),
      f: Math.max(0, (tgt.f || 0) - (fixedMacros.f || 0)),
    };

    let solvedFree = {};
    if (freeIngs.length > 0){
      const ingsForSolver = freeIngs.map(ing=>({
        id: ing.id,
        per100: {
          c: ing.per100.c || 0,
          p: ing.per100.p || 0,
          f: ing.per100.f || 0
        }
      }));
      solvedFree = solveGrams(ingsForSolver, adjTarget);
    }

    const grams = {};
    fixedIngs.forEach(ing => { grams[ing.id] = fixedGrams[ing.id] || 0; });
    freeIngs.forEach(ing  => {
      const g = solvedFree[ing.id] || 0;
      grams[ing.id] = Math.max(0, toNum(g));
    });

    const achieved = sumMacros(rec.ingredients, grams);
    return { grams, achieved };
  }catch(e){ console.error(e); return { grams:{}, achieved:{c:0,p:0,f:0} }; }
}



  function toleranceOK(target, got, tolOverride){
    const tol = (typeof tolOverride==="number") ? tolOverride : getTol();
    const within = (t,g)=> (t===0 ? Math.abs(g)<1e-3 : Math.abs(g-t) <= tol*Math.max(t,1e-6));
    return within(target.c,got.c) && within(target.p,got.p) && within(target.f,got.f);
  }

  const recipesList = $("recipesList");
 function renderRecipes(){
        if (state.recipeViewMode === "cards") {
               // Vista per categorie - la implementeremo dopo
       renderRecipesByCategory();
       } else {
             // Vista alfabetica - quella attuale
       renderRecipesList();
     }
 }

function renderRecipesByCategory(){
  recipesList.innerHTML = "";

  if (!state.recipes.length){
    const p = document.createElement("p");
    p.className = "small muted";
    p.textContent = t("recipes.emptyState");
    recipesList.appendChild(p);
    return;
  }

const groups = [
  { key: "breakfast", label: t("recipes.perMeal.mealBreakfast"), icon: "☕" },
  { key: "lunch",          label: t("recipes.perMeal.mealLunch"),           icon: "🍽️" },
  { key: "snack",          label: t("recipes.perMeal.mealSnack"),           icon: "🍏" },
  { key: "dinner",       label: t("recipes.perMeal.mealDinner"),         icon: "🌙" }
];

  const sorted = state.recipes
    .slice()
    .sort((a,b)=>(a.name || "").localeCompare(b.name || ""));

  groups.forEach(group => {

    const wrapper = document.createElement("div");
    wrapper.className = "card";
    wrapper.style.cursor = "pointer";
    wrapper.style.marginBottom = "12px";

    const header = document.createElement("div");
    header.className = "section-title";
    header.style.userSelect = "none";

    const hTitle = document.createElement("h2");
    hTitle.textContent = group.icon + " " + group.label;
    header.appendChild(hTitle);

    wrapper.appendChild(header);

    // contenitore interno ricette (nascosto di default)
    const inner = document.createElement("div");
    inner.style.display = "none";
    inner.style.padding = "8px 0";

    const recsForGroup = sorted.filter(rec =>
      rec.allowedMeals ? !!rec.allowedMeals[group.key] : true
    );

    if (!recsForGroup.length){
      const empty = document.createElement("p");
      empty.className = "small muted";
      empty.textContent = t("recipes.emptyForMeal");
      inner.appendChild(empty);
    } else {
      recsForGroup.forEach(rec => {
        const item = document.createElement("div");
        item.textContent = rec.name || t("recipes.unnamed");
        item.className = "small";
        item.style.padding = "4px 0";
        inner.appendChild(item);
      });
    }

    wrapper.appendChild(inner);

    // toggle apertura/chiusura
    header.addEventListener("click", () => {
      inner.style.display = inner.style.display === "none" ? "block" : "none";
    });

    recipesList.appendChild(wrapper);
  });
}


  function renderRecipesList(){
    recipesList.innerHTML = "";
    if (!state.recipes.length){
      const p = document.createElement("p");
      p.className = "small muted";
      p.textContent = t("recipes.hintCreateFromTitle");
      recipesList.appendChild(p);
    }

    state.recipes.slice().sort((a,b)=>(a.name||"").localeCompare(b.name||"")).forEach(rec => {
      const wrap = document.createElement("div");
      wrap.className = "card";

      const header = document.createElement("div");
      header.className = "section-title";
      const left = document.createElement("div");
      left.className = "disclosure";
      const chev = document.createElement("span"); chev.textContent = "▸"; chev.className = "chev" + (rec.open ? " open" : "");
      const title = document.createElement("button");
      title.className = "btn-ghost";
      title.style.border = "0";
      title.style.padding = "0";
      title.style.fontSize = "15px";
      title.style.cursor = "pointer";
      title.textContent = rec.name;
      left.appendChild(chev);
      left.appendChild(title);

      const actions = document.createElement("div");
      actions.className = "actions";
      const rn = document.createElement("button"); rn.className="btn-outline"; rn.textContent = t("recipes.renameButton");
      rn.onclick = ()=>{
        const name = prompt(t("recipes.renamePrompt", rec.name));
        if (name){ rec.name = name; save(); renderRecipes(); renderMeals(); renderPlanner(); renderDailyTotals(); }
      };
      const del = document.createElement("button"); del.className="btn-outline"; del.style.color="var(--bad)"; del.textContent = t("recipes.deleteButton");
      del.onclick = ()=>{
        if (!confirm(t("dialogs.deleteRecipeConfirm"))) return;
        state.recipes = state.recipes.filter(r=>r.id!==rec.id);
        Object.keys(state.meals).forEach(k=>{
          const st = state.meals[k];
          if (st.recipeId===rec.id){ st.recipeId=null; st.solution=null; }
        });
        dayDefs.forEach(d=>{
          mealKeys.forEach(m=>{
            if (state.weekPlan[d.key][m].recipeId===rec.id){
              state.weekPlan[d.key][m] = { recipeId:null, solution:null };
            }
          });
        });
        save(); renderRecipes(); renderMeals(); renderPlanner(); renderDailyTotals();
      };
      const addIng = document.createElement("button"); addIng.className="btn"; addIng.textContent = t("recipes.addIngredientButton");
      addIng.onclick = ()=>{
        rec.open = true; save(); renderRecipes();
        const form = document.getElementById("ing-form-"+rec.id);
        if (form) form.scrollIntoView({behavior:"smooth", block:"center"});
      };
      actions.appendChild(rn); actions.appendChild(del); actions.appendChild(addIng);

      header.appendChild(left);
      header.appendChild(actions);
      wrap.appendChild(header);

      function toggleOpen(){
        rec.open = !rec.open;
        save(); renderRecipes();
      }
      left.onclick = toggleOpen;
      title.onclick = toggleOpen;

      if (rec.open){
        
  // Allowed meals flags UI
  const flagsWrap = document.createElement("div");
  flagsWrap.className = "small";
  flagsWrap.style.display = "flex";
  flagsWrap.style.gap = "14px";
  flagsWrap.style.alignItems = "center";
  flagsWrap.style.margin = "6px 0 10px 0";
  const lab = document.createElement("label");
lab.className = "muted";
lab.textContent = t("recipes.availableForLabel");
flagsWrap.appendChild(lab);

const mkList = [
  [t("mealSplit.breakfast"), "breakfast"],
  [t("mealSplit.lunch"),     "lunch"],
  [t("mealSplit.snack"),     "snack"],
  [t("mealSplit.dinner"),    "dinner"]
];

  mkList.forEach(([l,k])=>{
    const w = document.createElement("label");
    w.className = "small";
    w.style.display = "inline-flex";
    w.style.alignItems = "center";
    w.style.gap = "6px";
    const cb = document.createElement("input");
    cb.type = "checkbox";
    if (!rec.allowedMeals) rec.allowedMeals = { breakfast:true,lunch:true,snack:true,dinner:true };
    cb.checked = !!rec.allowedMeals[k];
    cb.onchange = ()=>{ rec.allowedMeals[k] = !!cb.checked; save(); renderRecipes(); renderMeals(); renderPlanner(); };
    w.appendChild(cb);
    const span = document.createElement("span"); span.textContent = l;
    w.appendChild(span);
    flagsWrap.appendChild(w);
  });
  wrap.appendChild(flagsWrap);
        // Descrizione ricetta
   const descLabel = document.createElement("label");
   descLabel.className = "small muted";
   descLabel.textContent = t("recipes.autoFromLabels.descriptionLabel");
   descLabel.style.display = "block";
   descLabel.style.marginTop = "4px";

   const descArea = document.createElement("textarea");
   descArea.value = rec.description || "";
   descArea.rows = 3;
   descArea.style.width = "100%";
   descArea.style.margin = "4px 0 10px 0";
   descArea.style.fontSize = "12px";
   descArea.style.resize = "vertical";

   descArea.oninput = (e)=>{
     rec.description = e.target.value || "";
     save();
   };

   wrap.appendChild(descLabel);
   wrap.appendChild(descArea);
const table = document.createElement("table");
        table.className = "table";
        const thead = document.createElement("thead");
        thead.innerHTML = `
  <tr>
    <th>${t("recipes.autoFromLabels.libHeaderIngredient")}</th>
    <th class="right">${t("recipes.autoFromLabels.libHeaderC100")}</th>
    <th class="right">${t("recipes.autoFromLabels.libHeaderP100")}</th>
    <th class="right">${t("recipes.autoFromLabels.libHeaderF100")}</th>
    <th class="right">${t("recipes.autoFromLabels.libHeaderKcal100")}</th>
    <th class="right">${t("recipes.autoFromLabels.libHeaderKcalLabel100")}</th>
    <th class="right">${t("recipes.autoFromLabels.libHeaderPack")}</th>
    <th class="right">${t("recipes.autoFromLabels.libHeaderDefaultGrams")}</th>
    <th class="right">${t("recipes.autoFromLabels.libHeaderDefaultFixed")}</th>
    <th class="right">${t("recipes.autoFromLabels.libHeaderPerMeal")}</th>
    <th></th>
  </tr>
`;

        table.appendChild(thead);
        const tbody = document.createElement("tbody");

        rec.ingredients.forEach(ing=>{
          const tr = document.createElement("tr");
          const tdN = document.createElement("td"); tdN.textContent = ing.name; tr.appendChild(tdN);

          const tdC = document.createElement("td"); tdC.className="right";
          const cIn = document.createElement("input"); cIn.type="text"; cIn.setAttribute("inputmode","decimal");
          cIn.value = String(ing.per100.c).replace('.', ',');
          cIn.oninput = (e)=>{ ing.per100.c = clamp(e.target.value,0,100); save(); tdK.textContent = fmt(kcal(ing.per100),0); scheduleRecalc(); renderPlanner(); };
          tdC.appendChild(cIn); tr.appendChild(tdC);

          const tdP = document.createElement("td"); tdP.className="right";
          const pIn = document.createElement("input"); pIn.type="text"; pIn.setAttribute("inputmode","decimal");
          pIn.value = String(ing.per100.p).replace('.', ',');
          pIn.oninput = (e)=>{ ing.per100.p = clamp(e.target.value,0,100); save(); tdK.textContent = fmt(kcal(ing.per100),0); scheduleRecalc(); renderPlanner(); };
          tdP.appendChild(pIn); tr.appendChild(tdP);

          const tdF = document.createElement("td"); tdF.className="right";
          const fIn = document.createElement("input"); fIn.type="text"; fIn.setAttribute("inputmode","decimal");
          fIn.value = String(ing.per100.f).replace('.', ',');
          fIn.oninput = (e)=>{ ing.per100.f = clamp(e.target.value,0,100); save(); tdK.textContent = fmt(kcal(ing.per100),0); scheduleRecalc(); renderPlanner(); };
          tdF.appendChild(fIn); tr.appendChild(tdF);

          const tdK = document.createElement("td"); tdK.className="right"; tdK.textContent = fmt(kcal(ing.per100),0); tr.appendChild(tdK);

          const tdKL = document.createElement("td"); tdKL.className="right kcalLabelCell";
          const klIn = document.createElement("input"); klIn.type="text"; klIn.setAttribute("inputmode","decimal");
          klIn.value = (typeof ing.per100.kcalLabel !== "undefined" ? String(ing.per100.kcalLabel).replace('.', ',') : "");
          klIn.oninput = (e)=>{ const v=(e.target.value||'').replace(',','.'); const n=parseFloat(v); if(isFinite(n)){ ing.per100.kcalLabel = Math.max(0,n); } else { delete ing.per100.kcalLabel; } save(); scheduleRecalc(); };
          tdKL.appendChild(klIn); tr.appendChild(tdKL);
          // g per confezione (persistente in Archivio ingredienti)
          const tdPack = document.createElement("td"); tdPack.className = "right";
          const packIn = document.createElement("input");
          packIn.type = "text";
          packIn.setAttribute("inputmode","decimal");
          // lookup from ingredientLibrary by name
          const __libRef = state.ingredientLibrary.find(li => (li.name||"").toLowerCase().trim() === (ing.name||"").toLowerCase().trim());
          const __currentPack = (__libRef && typeof __libRef.packSize !== "undefined") ? __libRef.packSize : (typeof ing.packSize !== "undefined" ? ing.packSize : "");
          packIn.value = __currentPack === "" ? "" : String(__currentPack).replace(".", ",");
          packIn.oninput = (e)=>{
            const v = (e.target.value||"").replace(",", ".");
            const n = parseFloat(v);
            if (__libRef){
              if (isFinite(n) && n > 0){ __libRef.packSize = Math.max(1, n); }
              else { delete __libRef.packSize; }
            }
            if (isFinite(n) && n > 0){ ing.packSize = Math.max(1,n); } else { delete ing.packSize; }
            save();
          };
          tdPack.appendChild(packIn); tr.appendChild(tdPack);

          const tdDQ = document.createElement("td"); tdDQ.className = "right";
          const dqIn = document.createElement("input"); dqIn.type = "text"; dqIn.setAttribute("inputmode","decimal"); dqIn.value = (typeof ing.defaultQty!=="undefined" ? String(ing.defaultQty).replace('.', ',') : "");
          dqIn.oninput = (e)=>{ const v=(e.target.value||'').replace(',','.'); const n=parseFloat(v); if(isFinite(n)){ ing.defaultQty = Math.max(0,n); } else { delete ing.defaultQty; } save(); };
          tdDQ.appendChild(dqIn); tr.appendChild(tdDQ);
          const tdDF = document.createElement("td"); tdDF.className = "right";
          const dfCb = document.createElement("input"); dfCb.type = "checkbox"; dfCb.checked = !!ing.defaultFixed;
          dfCb.onchange = ()=>{ ing.defaultFixed = !!dfCb.checked; save(); };
          tdDF.appendChild(dfCb); tr.appendChild(tdDF);

const tdPM = document.createElement("td");
tdPM.className = "right";

const pmBtn = document.createElement("button");
pmBtn.className = "btn-outline";
pmBtn.textContent = t("recipes.perMeal.configureButton");
pmBtn.title = t("recipes.perMeal.configureHint");

pmBtn.onclick = () => {
  const mealMap = [
    [t("recipes.perMeal.mealBreakfast"), "breakfast"],
    [t("recipes.perMeal.mealLunch"),     "lunch"],
    [t("recipes.perMeal.mealSnack"),     "snack"],
    [t("recipes.perMeal.mealDinner"),    "dinner"]
  ];

  const meals = mealMap.filter(([_, k]) => !rec.allowedMeals || rec.allowedMeals[k]);
  if (!meals.length) {
    alert(t("alerts.noMealsEnabledForRecipe"));
    return;
  }

  ing.perMeal = ing.perMeal || {};

  meals.forEach(([label, key]) => {

    const mealLabelKeyMap = {
      breakfast: "recipes.perMeal.mealBreakfast",
      lunch:     "recipes.perMeal.mealLunch",
      snack:     "recipes.perMeal.mealSnack",
      dinner:    "recipes.perMeal.mealDinner"
    };

    const mealLabelKey = mealLabelKeyMap[key];
    const mealLabel = mealLabelKey ? t(mealLabelKey) : label;

    const current = ing.perMeal[key] || { defaultQty: undefined, defaultFixed: false };

    const q = prompt(
      t("recipes.perMeal.fixedGramsPrompt", {
        ingredient: ing.name,
        meal: mealLabel
      }),
      typeof current.defaultQty !== "undefined" ? String(current.defaultQty) : ""
    );

    if (q === null) return;

    const num = parseFloat(String(q).replace(",", "."));
    if (!isNaN(num)) {
      ing.perMeal[key] = ing.perMeal[key] || {};
      ing.perMeal[key].defaultQty = Math.max(0, num);
    } else {
      if (ing.perMeal[key]) delete ing.perMeal[key].defaultQty;
    }

    const fx = confirm(
      t("recipes.perMeal.fixedFlagConfirm", {
        ingredient: ing.name,
        meal: mealLabel
      })
    );

    ing.perMeal[key] = ing.perMeal[key] || {};
    ing.perMeal[key].defaultFixed = !!fx;
  });

  save();
  renderRecipes();
  renderMeals();
  renderPlanner();
};

tdPM.appendChild(pmBtn);
tr.appendChild(tdPM);


          const tdA = document.createElement("td"); tdA.className="right";
          const rm = document.createElement("button"); rm.className="btn-outline"; rm.style.color="var(--bad)"; 
          rm.textContent = t("recipes.perMeal.removeButton"); rm.title = t("recipes.perMeal.removeHint");
          rm.onclick = ()=>{ if (!confirm(t("alerts.removeIngredientConfirm"))) return; rec.ingredients = rec.ingredients.filter(x=>x.id!==ing.id); save(); renderRecipes(); renderMeals(); renderPlanner(); renderDailyTotals(); };
          tdA.appendChild(rm); tr.appendChild(tdA);
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        wrap.appendChild(table);

        const form = document.createElement("div");
        form.className = "grid";
        form.id = "ing-form-"+rec.id;
        form.style.gridTemplateColumns = "1fr auto 2fr auto";
        form.style.alignItems = "end";
        form.style.gap = "8px";

        const lab1 = document.createElement("label"); lab1.textContent = t("recipes.perMeal.addFromLibrary");
        lab1.style.gridColumn="1/2";
        const sel = document.createElement("select"); sel.style.gridColumn="1/2"; sel.style.width="100%";
        const opt0 = document.createElement("option"); opt0.value=""; opt0.textContent = t("recipes.perMeal.selectIngredientPlaceholder");
        sel.appendChild(opt0);
        state.ingredientLibrary.slice().sort((a,b)=>a.name.localeCompare(b.name)).forEach(li=>{
          const o=document.createElement("option"); o.value=li.id; o.textContent=li.name; sel.appendChild(o);
        });
        const btnAdd = document.createElement("button"); btnAdd.className="btn-outline"; btnAdd.textContent = t("recipes.perMeal.addButton");
        btnAdd.onclick = ()=>{
          const id = sel.value; if (!id) return;
          const li = state.ingredientLibrary.find(x=>x.id===id);
          if (!li) return;
          rec.ingredients.push({ id: uid(), name: li.name, per100: {...li.per100} });
          save(); renderRecipes(); renderMeals(); renderPlanner(); renderDailyTotals();
        };

        const lab2 = document.createElement("label"); lab2.textContent = t("recipes.autoFromLabels.newIngredientLabel");
        const nameIn = document.createElement("input"); nameIn.type="text"; nameIn.placeholder = t("recipes.autoFromLabels.newIngredientNamePlaceholder");
        const cIn2 = document.createElement("input"); cIn2.type="text"; cIn2.setAttribute("inputmode","decimal"); cIn2.placeholder = t("recipes.autoFromLabels.newIngredientCPlaceholder");
        const pIn2 = document.createElement("input"); pIn2.type="text"; pIn2.setAttribute("inputmode","decimal"); pIn2.placeholder = t("recipes.autoFromLabels.newIngredientPPlaceholder");
        const fIn2 = document.createElement("input"); fIn2.type="text"; fIn2.setAttribute("inputmode","decimal"); fIn2.placeholder = t("recipes.autoFromLabels.newIngredientFPlaceholder");
        const packIn2 = document.createElement("input"); packIn2.type="text"; packIn2.setAttribute("inputmode","decimal"); packIn2.placeholder = t("recipes.autoFromLabels.newIngredientPackPlaceholder");
        const btnNew = document.createElement("button"); btnNew.className="btn"; btnNew.textContent = t("recipes.autoFromLabels.createAndAddButton");
        btnNew.onclick = ()=>{
          const name = (nameIn.value||"").trim();
          if (!name) { alert(t("alerts.nameRequired")); return; }
          const per100 = { c: clamp(cIn2.value,0,1000), p: clamp(pIn2.value,0,1000), f: clamp(fIn2.value,0,1000) };
          const key = name.toLowerCase().trim();
          let existing = state.ingredientLibrary.find(x=>x.name.toLowerCase().trim()===key);
          if (!existing){
            existing = { id: uid(), name, per100: {...per100} };
            state.ingredientLibrary.push(existing);
          } else {
            existing.per100 = {...per100};
          }
          const nPack = parseFloat(String(packIn2.value||"").replace(",","."));
          if (isFinite(nPack) && nPack > 0){ existing.packSize = Math.max(1, nPack); }
          rec.ingredients.push({ id: uid(), name: existing.name, per100: {...existing.per100} });
          nameIn.value=""; cIn2.value=""; pIn2.value=""; fIn2.value=""; packIn2.value="";
          save(); renderRecipes(); renderMeals(); renderPlanner(); renderDailyTotals();
        };

        form.appendChild(lab1);
        form.appendChild(sel);
        form.appendChild(btnAdd);
        form.appendChild(lab2);
        form.appendChild(nameIn);
        form.appendChild(cIn2);
        form.appendChild(pIn2);
        form.appendChild(fIn2);
        form.appendChild(packIn2);
        form.appendChild(btnNew);
        wrap.appendChild(form);
      }

      recipesList.appendChild(wrap);
    });
  }

const mealsRoot = $("meals");

// === Preview ricetta (solo descrizione) + modifica rapida ===
function editRecipeFromPreview(rec){
  if (!rec) return;

  // Chiudi il popup
  closeRecipePreview();

  // Assicura vista "lista" per le ricette
  state.recipeViewMode = "list";

  // Apri solo questa ricetta, chiudi le altre
  (state.recipes || []).forEach(r => {
    r.open = (r.id === rec.id);
  });

  save();
  renderRecipes();

  // Dopo il render, scrolla sulla form ingredienti con offset sotto la topbar
  setTimeout(function(){
    var form = document.getElementById("ing-form-" + rec.id);
    if (!form) return;

// risali fino al contenitore .card della ricetta
    var card = form;
    while (card && (!card.classList || !card.classList.contains("card"))) {
      card = card.parentElement;
    }
    var target = card || form;

    // altezza reale dell'header (la banda top)
    var topbar = document.querySelector("header");
    var offset = topbar ? (topbar.offsetHeight + 16) : 80; // 16px di respiro

    var top = target.getBoundingClientRect().top + window.pageYOffset - offset;

    window.scrollTo({
      top: top,
      behavior: "smooth"
    });
  }, 80);
}
function openRecipePreview(rec){
  if (!rec) return;
  const backdrop = document.getElementById("recipePreviewBackdrop");
  if (!backdrop) return;

  const titleEl = document.getElementById("recipePreviewTitle");
  const descEl  = document.getElementById("recipePreviewDesc");

  if (titleEl) {
    titleEl.textContent = rec.name || t("recipes.previewTitle");
  }

  if (descEl) {
    const txt = (rec.description || "").trim();
    descEl.textContent = txt || t("recipes.noDescription");
  }

  // Bottone CHIUDI
  const closeBtn = document.getElementById("recipePreviewCloseBtn");
  if (closeBtn) {
    closeBtn.onclick = function(e){
      e.stopPropagation();
      closeRecipePreview();
    };
  }

  // Bottone MODIFICA
  const editBtn = document.getElementById("recipePreviewEditBtn");
  if (editBtn) {
    editBtn.onclick = function(e){
      e.stopPropagation();
      editRecipeFromPreview(rec);
    };
  }

  // Chiudi cliccando sullo sfondo scuro
  backdrop.onclick = function(e){
    if (e.target === backdrop) {
      closeRecipePreview();
    }
  };

  backdrop.style.display = "flex";
}

function closeRecipePreview(){
  const backdrop = document.getElementById("recipePreviewBackdrop");
  if (!backdrop) return;
  backdrop.style.display = "none";
}


  function setupRecipePreviewModal(){
    const backdrop = document.getElementById("recipePreviewBackdrop");
    if (!backdrop) return;

    // chiusura cliccando fuori
    backdrop.addEventListener("click", function(e){
      if (e.target === backdrop) {
        closeRecipePreview();
      }
    });

    const btn = document.getElementById("recipePreviewCloseBtn");
    if (btn) btn.onclick = closeRecipePreview;
  }

  function renderMeals(){
        mealsRoot.innerHTML = "";

    const mealHeaderDefs = [
      { key: "breakfast", i18nKey: "week.summaryHeaders.breakfast" },
      { key: "lunch",     i18nKey: "week.summaryHeaders.lunch" },
      { key: "snack",     i18nKey: "week.summaryHeaders.snack" },
      { key: "dinner",    i18nKey: "week.summaryHeaders.dinner" }
    ];

    mealHeaderDefs.forEach(({ key, i18nKey }) => {
      const st = state.meals[key];
      const rec = state.recipes.find(r => r.id === st.recipeId) || null;
      const target = targetFor(key);
      const card = document.createElement("div");
      card.className = "card";

      const top = document.createElement("div");
      top.className = "section-title";

      const h = document.createElement("h3");
      h.style.margin = "0";
      h.style.fontSize = "15px";
      // titolo agganciato alle traduzioni
      h.setAttribute("data-i18n", i18nKey);
      h.textContent = t(i18nKey);

      const actions = document.createElement("div");
      actions.className = "actions";

      const lock = document.createElement("button");
      lock.className = "btn-outline";
      lock.textContent = st.locked ? t("meals.unlock") : t("meals.lock");
      lock.onclick = () => {
        st.locked = !st.locked;
        save();
        renderMeals();
        renderDailyTotals();
      };

      const recalc = document.createElement("button");
      recalc.className = "btn";
      recalc.textContent = t("meals.recalc");
      recalc.disabled = !(rec || (st.split_v8 && st.split_v8.enabled && ((st.split_v8.primo && st.split_v8.primo.recipeId) || (st.split_v8.secondo && st.split_v8.secondo.recipeId))));
      recalc.onclick = () => {
        solveMeal(key);
        renderMeals();
        renderDailyTotals();
      };

      actions.appendChild(lock);
      actions.appendChild(recalc);
      top.appendChild(h);
      top.appendChild(actions);
      card.appendChild(top);

      const row1 = document.createElement("div"); row1.className="grid grid-12";
      const left = document.createElement("div"); left.style.gridColumn="span 6";
      const lab = document.createElement("label");
      lab.textContent = t("meals.recipeLabel");
      const sel = document.createElement("select"); sel.style.width="100%"; sel.style.padding="10px"; sel.style.border="1px solid var(--border)"; sel.style.borderRadius="10px";
      sel.disabled = st.locked;
      const opt0 = document.createElement("option");
      opt0.value = "";
      opt0.textContent = t("meals.selectRecipePlaceholder");
      sel.appendChild(opt0);
      
state.recipes
  .filter(r => (r.allowedMeals ? !!r.allowedMeals[key] : true))
  .slice()
  .sort((a,b)=> (a.name||"").localeCompare(b.name||""))
  .forEach(r=>{ const o=document.createElement("option"); o.value=r.id; o.textContent=r.name; sel.appendChild(o); });

      sel.value = st.recipeId || "";
      sel.onchange = ()=>{ st.recipeId = sel.value || null; st.solution = null; 
      // Precarica quantità fisse di default dagli ingredienti della ricetta
      st.fixed = st.fixed || {};
      const recSel = state.recipes.find(r=>r.id===st.recipeId);
      if (recSel && recSel.ingredients){
        recSel.ingredients.forEach(ing=>{
          const dq = (typeof ing.defaultQty!=="undefined") ? Number((""+ing.defaultQty).toString().replace(',','.')) : null;
          if (ing.defaultFixed && isFinite(dq) && dq>0){ st.fixed[ing.id] = { g: dq, fixed: true }; }
        });
      }
      save(); writeMealToPlanner(key); renderMeals(); renderDailyTotals(); solveMeal(key); writeMealToPlanner(key); renderMeals(); renderDailyTotals(); };
            // Label sopra
      left.appendChild(lab);

      // Riga: select ricetta + icona libro a destra
      const selRow = document.createElement("div");
      selRow.style.display = "flex";
      selRow.style.alignItems = "center";
      selRow.style.gap = "6px";

      // la select resta identica, solo messa dentro la riga
      selRow.appendChild(sel);

      // se c'è una ricetta selezionata, mostro l'icona libro
      if (rec){
        const iconBtn = document.createElement("button");
        iconBtn.type = "button";
        iconBtn.innerHTML = "📖";
        iconBtn.title = "Mostra descrizione ricetta";
        iconBtn.style.border = "none";
        iconBtn.style.background = "none";
        iconBtn.style.cursor = "pointer";
        iconBtn.style.padding = "0";
        iconBtn.style.fontSize = "18px";
        iconBtn.style.lineHeight = "1";

        iconBtn.onclick = ()=>{ openRecipePreview(rec); };

        selRow.appendChild(iconBtn);
      }

      left.appendChild(selRow);


      const right = document.createElement("div"); right.style.gridColumn="span 6"; right.className="small muted";
      right.style.display="flex"; right.style.alignItems="end"; right.style.justifyContent="flex-end";
      right.textContent = `Target: C ${fmt(target.c)} / P ${fmt(target.p)} / F ${fmt(target.f)} — kcal ${fmt(kcal(target),0)}`;
      row1.appendChild(left); row1.appendChild(right);
      card.appendChild(row1);
      // Per-meal tolerance controls
      const tolWrap = document.createElement("div"); tolWrap.className="small"; tolWrap.style.marginTop="6px";
      tolWrap.style.display="flex"; tolWrap.style.alignItems="center"; tolWrap.style.gap="8px";
      const tolLab = document.createElement("label");
tolLab.className = "muted";
// usa la chiave già presente nei JSON (IT/EN)
tolLab.setAttribute("data-i18n", "recipes.autoFromLabels.mealToleranceLabel");
tolLab.textContent = t("recipes.autoFromLabels.mealToleranceLabel");

      const tolIn = document.createElement("input"); tolIn.type="number"; tolIn.min="0"; tolIn.max="50"; tolIn.step="0.5"; tolIn.style.width="80px"; tolIn.style.padding="6px 8px"; tolIn.style.border="1px solid var(--border)"; tolIn.style.borderRadius="8px";
      tolIn.value = String(getMealTolPct(key));
      tolIn.oninput = ()=>{ /* no live rerender while typing */ };
      tolIn.onblur = ()=>{
        const raw = (tolIn.value||"").replace(",", ".");
        const num = parseFloat(raw);
        const v = (isFinite(num) ? Math.max(0, Math.min(50, num)) : null);
        state.meals[key] = state.meals[key] || {};
        if (v === null) { delete state.meals[key].tol; } else { state.meals[key].tol = v/100; }
        save(); solveMeal(key); renderMeals(); renderDailyTotals();
      };
      const tolReset = document.createElement("button");
tolReset.className = "btn-outline";

// aggancia al sistema di traduzioni
tolReset.setAttribute("data-i18n", "recipes.autoFromLabels.useGlobalTolerance");
tolReset.textContent = t("recipes.autoFromLabels.useGlobalTolerance");

tolReset.onclick = () => {
  if (state.meals[key]) {
    delete state.meals[key].tol;
    save();
    solveMeal(key);
    renderMeals();
    renderDailyTotals();
  }
};

      tolWrap.appendChild(tolLab); tolWrap.appendChild(tolIn); tolWrap.appendChild(document.createTextNode("%")); tolWrap.appendChild(tolReset);
      card.appendChild(tolWrap);

      // === Split Primo/Secondo (v8 safe, opzionale) ===
      try{
        if (key==='lunch' || key==='dinner'){
          st.split_v8 = st.split_v8 || { enabled:false, mode:'percent',
            primo:{ recipeId:null, percent:{C:50,P:50,F:50}, manual:{C:0,P:0,F:0} },
            secondo:{ recipeId:null, percent:{C:50,P:50,F:50}, manual:{C:0,P:0,F:0} }
          };
          const splitRow = document.createElement('div'); splitRow.className='small'; splitRow.style.marginTop='6px';
          splitRow.style.display='flex'; splitRow.style.alignItems='center'; splitRow.style.gap='10px';
          const wrapLab = document.createElement('label'); wrapLab.className='muted'; wrapLab.style.display='inline-flex'; wrapLab.style.alignItems='center'; wrapLab.style.gap='6px';
          const cb = document.createElement('input'); cb.type='checkbox'; cb.checked=!!st.split_v8.enabled;
          cb.onchange = ()=>{ st.split_v8.enabled = !!cb.checked; if (st.split_v8.enabled) { st._lastSingle = { recipeId: st.recipeId || null, solution: st.solution || null, fixed: JSON.parse(JSON.stringify(st.fixed||{})) }; st.recipeId = null; st.solution = null; if (st.fixed) st.fixed = {}; writeMealToPlanner && writeMealToPlanner(key); } else { if (st._lastSingle && st._lastSingle.recipeId) { st.recipeId = st._lastSingle.recipeId; st.solution = st._lastSingle.solution || null; st.fixed = JSON.parse(JSON.stringify(st._lastSingle.fixed||{})); } writeMealToPlanner && writeMealToPlanner(key); } save(); renderMeals(); renderDailyTotals(); };
            wrapLab.appendChild(cb);
                        wrapLab.appendChild(document.createTextNode(t("split.enableLabel")));
          const modeSel = document.createElement('select');
                    [
            {v:'percent', labelKey:'split.modePercent'},
            {v:'manual',  labelKey:'split.modeManual'},
            {v:'auto',    labelKey:'split.modeAuto'}
          ].forEach(cfg=>{
            const o = document.createElement('option');
            o.value = cfg.v;
            o.textContent = t(cfg.labelKey);
            modeSel.appendChild(o);
          });
          modeSel.value = st.split_v8.mode || 'percent';
          modeSel.onchange = ()=>{ st.split_v8.mode = modeSel.value; save(); renderMeals(); };
          splitRow.appendChild(wrapLab); splitRow.appendChild(modeSel);
          card.appendChild(splitRow);

          if (st.split_v8.enabled){
            // Enforce complementarity for Carbo/Proteine/Grassi (percent mode) at render-time; primo is the source
            if ((st.split_v8.mode||'percent')==='percent'){
              const pc = Math.max(0, Math.min(100, Number(st.split_v8.primo.percent.C)||0));
              st.split_v8.primo.percent.C = pc;
              st.split_v8.secondo.percent.C = 100 - pc;
              const pp = Math.max(0, Math.min(100, Number(st.split_v8.primo.percent.P)||0));
              st.split_v8.primo.percent.P = pp;
              st.split_v8.secondo.percent.P = 100 - pp;
              const pf = Math.max(0, Math.min(100, Number(st.split_v8.primo.percent.F)||0));
              st.split_v8.primo.percent.F = pf;
              st.split_v8.secondo.percent.F = 100 - pf;
            }
            save();
            function slotBlock(slotKey, labelSlot){
              const slot = st.split_v8[slotKey];
              const otherSlotKey = (slotKey==='primo' ? 'secondo' : 'primo');
              const otherSlot = st.split_v8[otherSlotKey] || {};
              const otherRecipeId = otherSlot.recipeId || null;

              // Riga: Select ricetta + Target slot
              const rTop = document.createElement('div'); rTop.className='grid grid-12';
              const left = document.createElement('div'); left.style.gridColumn='span 6';
              const labR = document.createElement('label'); labR.textContent = t("split.slotRecipeLabel", { slot: labelSlot });
              const sel = document.createElement('select'); sel.style.width='100%'; sel.style.padding='10px'; sel.style.border='1px solid var(--border)'; sel.style.borderRadius='10px';
              const opt0 = document.createElement("option");
              opt0.value = "";
              opt0.textContent = t("meals.selectRecipePlaceholder");
              sel.appendChild(opt0);

              state.recipes
                .filter(r => (r.allowedMeals ? !!r.allowedMeals[key] : true)
                  && (!st.split_v8.enabled || !otherRecipeId || r.id !== otherRecipeId))
                .slice().sort((a,b)=> (a.name||'').localeCompare(b.name||''))
                .forEach(r=>{ const o=document.createElement('option'); o.value=r.id; o.textContent=r.name; sel.appendChild(o); });
              sel.value = slot.recipeId || '';
              sel.onchange = ()=>{ slot.recipeId = sel.value || null; save(); renderMeals(); renderDailyTotals(); };
              left.appendChild(labR); left.appendChild(sel);

              const right = document.createElement('div'); right.style.gridColumn='span 6'; right.className='small muted';
              const tgt = __split_v8_target(key, st.split_v8.mode, slot);
              right.style.display='flex'; right.style.alignItems='end'; right.style.justifyContent='flex-end';
              function __updateRight(){
  const tgt = __split_v8_target(key, st.split_v8.mode || 'percent', slot);
      const c = tgt.c || 0;
      const p = tgt.p || 0;
      const f = tgt.f || 0;
      right.textContent = t("split.slotTargetLabel", {
              slot: labelSlot,
              c: fmt(c),
         p: fmt(p),
         f: fmt(f),
         kcal: fmt(4*c + 4*p + 9*f, 0)
       });
   }
 __updateRight();

__updateRight();
              rTop.appendChild(left); rTop.appendChild(right);
              card.appendChild(rTop);

              // Riga: Percentuale o Manuale
              if ((st.split_v8.mode||'percent')==='manual'){
                const rM=document.createElement('div'); rM.className='grid grid-4'; rM.style.marginTop='6px';
                const lc=document.createElement('label'); lc.textContent = t("split.manualCLabel"); const ic=document.createElement('input'); ic.type='number'; ic.step='0.1'; ic.value=slot.manual.C||0;
                const lp=document.createElement('label'); lp.textContent = t("split.manualPLabel"); const ip=document.createElement('input'); ip.type='number'; ip.step='0.1'; ip.value=slot.manual.P||0;
                const lf=document.createElement('label'); lf.textContent = t("split.manualFLabel"); const iff=document.createElement('input'); iff.type='number'; iff.step='0.1'; iff.value=slot.manual.F||0;
                ic.oninput=()=>{ slot.manual.C=Number(ic.value)||0; save(); __updateRight(); }; ic.onblur=()=>{ renderMeals(); };
                ip.oninput=()=>{ slot.manual.P=Number(ip.value)||0; save(); __updateRight(); }; ip.onblur=()=>{ renderMeals(); };
                iff.oninput=()=>{ slot.manual.F=Number(iff.value)||0; save(); __updateRight(); }; iff.onblur=()=>{ renderMeals(); };
                rM.appendChild(lc); rM.appendChild(ic); rM.appendChild(lp); rM.appendChild(ip); rM.appendChild(lf); rM.appendChild(iff);
                card.appendChild(rM);
              } else if ((st.split_v8.mode||'percent')==='percent') {
                const rP=document.createElement('div'); rP.className='grid grid-4'; rP.style.marginTop='6px';
                const lc=document.createElement('label'); lc.textContent='% C'; const ic=document.createElement('input'); ic.type='number'; ic.step='0.1'; ic.value=slot.percent.C||0; ic.setAttribute('data-split', slotKey); ic.setAttribute('data-macro','C');
                const lp=document.createElement('label'); lp.textContent='% P'; const ip=document.createElement('input'); ip.type='number'; ip.step='0.1'; ip.value=slot.percent.P||0; ip.setAttribute('data-split', slotKey); ip.setAttribute('data-macro','P');
                const lf=document.createElement('label'); lf.textContent='% F'; const iff=document.createElement('input'); iff.type='number'; iff.step='0.1'; iff.value=slot.percent.F||0; iff.setAttribute('data-split', slotKey); iff.setAttribute('data-macro','F');
                ic.oninput=()=>{   const v = Math.max(0, Math.min(100, Number(ic.value)||0));   if (slotKey==='primo'){ st.split_v8.primo.percent.C = v; } else { st.split_v8.primo.percent.C = Math.max(0, Math.min(100, 100 - v)); }   const otherKey = (slotKey==='primo' ? 'secondo' : 'primo');   const otherVal = 100 - st.split_v8.primo.percent.C;   const oi = document.querySelector("input[data-split='"+otherKey+"'][data-macro='C']"); if (oi) { oi.value = String(otherVal); }   save(); __updateRight(); }; ic.onblur=()=>{};
                ip.oninput=()=>{ const v=Math.max(0,Math.min(100,Number(ip.value)||0)); if(slotKey==='primo'){ st.split_v8.primo.percent.P=v; } else { st.split_v8.primo.percent.P=Math.max(0,Math.min(100,100-v)); }
  const otherKey=(slotKey==='primo'?'secondo':'primo'); const otherVal=100 - st.split_v8.primo.percent.P; const oi=document.querySelector("input[data-split='"+otherKey+"'][data-macro='P']"); if(oi){ oi.value=String(otherVal); }
  save(); __updateRight(); };
ip.onblur=()=>{};
                iff.oninput=()=>{ const v=Math.max(0,Math.min(100,Number(iff.value)||0)); if(slotKey==='primo'){ st.split_v8.primo.percent.F=v; } else { st.split_v8.primo.percent.F=Math.max(0,Math.min(100,100-v)); }
  const otherKey=(slotKey==='primo'?'secondo':'primo'); const otherVal=100 - st.split_v8.primo.percent.F; const oi=document.querySelector("input[data-split='"+otherKey+"'][data-macro='F']"); if(oi){ oi.value=String(otherVal); }
  save(); __updateRight(); };
iff.onblur=()=>{};
                rP.appendChild(lc); rP.appendChild(ic); rP.appendChild(lp); rP.appendChild(ip); rP.appendChild(lf); rP.appendChild(iff);
                card.appendChild(rP);
              }

              // Tabella ingredienti/grammi (read-only per sicurezza)
              const recSel = state.recipes.find(r=>r.id===slot.recipeId);
              if (recSel){
                // Cerco prima i dati già risolti nello state (solveMealSplit)
                let gramsById = {};
                let tot = {c:0,p:0,f:0};
                if (st.solution && st.solution.split_v8 && st.solution.split_v8[slotKey]){
                  const solSlot = st.solution.split_v8[slotKey];
                  gramsById = solSlot.grams || {};
                  tot = solSlot.achieved || {c:0,p:0,f:0};
                } else {
                  // Fallback: calcolo al volo se non c'è ancora una soluzione salvata
                  const tgtLocal = __split_v8_target(key, st.split_v8.mode || 'percent', slot);
                  const solved = __split_v8_solve(key, recSel, tgtLocal);
                  gramsById = solved.grams || {};
                  tot = solved.achieved || {c:0,p:0,f:0};
                }

                const info = document.createElement('div'); info.className='small muted'; info.style.marginTop='6px';
                info.textContent = t("recipes.autoFromLabels.suggestedHeader", { slotLabel: labelSlot });
                card.appendChild(info);
                const table=document.createElement('table'); table.className='table';
                const thead=document.createElement('thead');
                thead.innerHTML = `
  <tr>
    <th>${t("recipes.autoFromLabels.summaryHeaderIngredient")}</th>
    <th class="right">${t("recipes.autoFromLabels.summaryHeaderGrams")}</th>
    <th class="right">${t("recipes.autoFromLabels.summaryHeaderFixed")}</th>
    <th class="right">${t("recipes.autoFromLabels.summaryHeaderC")}</th>
    <th class="right">${t("recipes.autoFromLabels.summaryHeaderP")}</th>
    <th class="right">${t("recipes.autoFromLabels.summaryHeaderF")}</th>
    <th class="right">${t("recipes.autoFromLabels.summaryHeaderKcal")}</th>
    <th class="right kcalLabelCell">${t("recipes.autoFromLabels.summaryHeaderKcalLabel")}</th>
  </tr>`;
                table.appendChild(thead);
                const tbody=document.createElement('tbody');
                recSel.ingredients.forEach(ing=>{
                  const tr=document.createElement('tr');
                  const tdN=document.createElement('td'); tdN.textContent=ing.name;
                  const grams=gramsById[ing.id]||0;
                  const tdG=document.createElement('td'); tdG.className='right';
                  const gIn=document.createElement('input'); gIn.type='text'; gIn.className='smallInput right'; gIn.value=String(grams).replace('.',','); gIn.readOnly=true; tdG.appendChild(gIn);
                  const tdFix=document.createElement('td'); tdFix.className='center';
                  const cfx=document.createElement('input'); cfx.type='checkbox'; cfx.disabled=true; tdFix.appendChild(cfx);
                  const c=(ing.per100.c/100)*grams, p=(ing.per100.p/100)*grams, f=(ing.per100.f/100)*grams;
                  function tdR(x){ const td=document.createElement('td'); td.className='right'; td.textContent=fmt(x,1); return td; }
                  const tdK=document.createElement('td'); tdK.className='right'; tdK.textContent=fmt(4*c+4*p+9*f,0);
                  const tdKL=document.createElement('td'); tdKL.className='right kcalLabelCell'; const kLab=(kcalLabel100(ing.per100)/100)*grams; tdKL.textContent=fmt(kLab,0);
                  tr.appendChild(tdN); tr.appendChild(tdG); tr.appendChild(tdFix); tr.appendChild(tdR(c)); tr.appendChild(tdR(p)); tr.appendChild(tdR(f)); tr.appendChild(tdK); tr.appendChild(tdKL);
                  tbody.appendChild(tr);
                });
                table.appendChild(tbody); card.appendChild(table);
                const totRow=document.createElement('div'); totRow.className='small'; totRow.style.marginTop='6px';
                      totRow.innerHTML =
                                  `${labelSlot} — C ${fmt(tot.c,1)} / P ${fmt(tot.p,1)} / F ${fmt(tot.f,1)} ` +
                                  `— kcal ${fmt(4*tot.c+4*tot.p+9*tot.f,0)} ` +
                                  `<span class="tag">${t("split.strictTag")}</span>`;
                           card.appendChild(totRow);

                return tot;
              } else {
                return {c:0,p:0,f:0};
              }
            }


            // Ordine fisso: PRIMO (sopra) poi SECONDO (sotto)
              const A = slotBlock('primo', t("split.slotPrimo"));
                             const B = slotBlock('secondo', t("split.slotSecondo"));
            const sum = { c:(A?.c||0)+(B?.c||0), p:(A?.p||0)+(B?.p||0), f:(A?.f||0)+(B?.f||0) };
            const tgtMeal=targetFor(key);
            const sumRow=document.createElement('div'); sumRow.className='small'; sumRow.style.marginTop='6px';
            const ok=toleranceOK({c:tgtMeal.c,p:tgtMeal.p,f:tgtMeal.f}, sum, getMealTol(key));
                   const withinTol = t("dailyTotals.totalWithinTol", { pct: getMealTolPct(key) });
                             const outOfTol = t("dailyTotals.totalOutOfTol", { pct: getMealTolPct(key) });
                             const statusHtml = ok
                             ? `<span class="pill ok">${withinTol}</span>`
                        : `<span class="pill bad">${outOfTol}</span>`;
                            sumRow.innerHTML =
                          `${t("split.sumRowLabel")} — C ${fmt(sum.c,1)} / P ${fmt(sum.p,1)} / F ${fmt(sum.f,1)} ` +
                         `— kcal ${fmt(kcal(sum),0)} ` +
                          statusHtml;
                card.appendChild(sumRow);
          }
        }
      }catch(err){ console.error('split v8 error', err); }


         if (rec){
                        const info = document.createElement("div");
                       info.className = "small muted";
                       info.style.marginTop = "6px";

                     // aggancia il nodo al sistema di traduzioni
                     info.setAttribute("data-i18n", "mealSplit.ingredientsInfo");

                      // testo iniziale coerente con la lingua attuale
                     info.textContent = t("mealSplit.ingredientsInfo");

                    card.appendChild(info);

        const table = document.createElement("table"); table.className="table";
        const thead = document.createElement("thead");
        thead.innerHTML =
  "<tr>"
+ "<th data-i18n=\"recipes.autoFromLabels.summaryHeaderIngredient\">Ingrediente</th>"
+ "<th class='right' data-i18n=\"recipes.autoFromLabels.summaryHeaderGrams\">g</th>"
+ "<th class='right' data-i18n=\"recipes.autoFromLabels.summaryHeaderFixed\">Fissa</th>"
+ "<th class='right' data-i18n=\"recipes.autoFromLabels.summaryHeaderC\">C (g)</th>"
+ "<th class='right' data-i18n=\"recipes.autoFromLabels.summaryHeaderP\">P (g)</th>"
+ "<th class='right' data-i18n=\"recipes.autoFromLabels.summaryHeaderF\">F (g)</th>"
+ "<th class='right' data-i18n=\"recipes.autoFromLabels.summaryHeaderKcal\">kcal ~</th>"
+ "<th class='right kcalLabelCell' data-i18n=\"recipes.autoFromLabels.summaryHeaderKcalLabel\">kcal etichetta ~</th>"
+ "</tr>";

        table.appendChild(thead);
        const tbody = document.createElement("tbody");

        rec.ingredients.forEach(ing=>{
          const tr = document.createElement("tr");
          const tdN = document.createElement("td"); tdN.textContent = ing.name;

          const fx = (state.meals[key].fixed||{});
          const fxo = fx[ing.id] || { g:0, fixed:false };
          const gCalc = st.solution?.grams?.[ing.id] ?? 0;
          const gCurrent = fxo.fixed ? (fxo.g||0) : gCalc;
          const m = { c:(ing.per100.c/100)*gCurrent, p:(ing.per100.p/100)*gCurrent, f:(ing.per100.f/100)*gCurrent };

const tdG = document.createElement("td");
tdG.className = "right grams-cell";

const gIn = document.createElement("input");
gIn.type = "text";
gIn.setAttribute("inputmode","decimal");
gIn.style.width = "100%";
gIn.value = String(gCurrent).replace('.', ',');

gIn.oninput = (e) => {
  const v = (e.target.value || '').replace(',', '.');
  const n = isFinite(parseFloat(v)) ? Math.max(parseFloat(v), 0) : 0;
  state.meals[key].fixed = state.meals[key].fixed || {};
  const prev = state.meals[key].fixed[ing.id] || { g:0, fixed:false };
  state.meals[key].fixed[ing.id] = { g:n, fixed: prev.fixed };
  save();
};

gIn.onblur = () => {
  solveMeal(key);
  renderDailyTotals();
};

tdG.appendChild(gIn);
tr.appendChild(tdG);

          const tdFix = document.createElement("td"); tdFix.className="right";
          const cb = document.createElement("input"); cb.type="checkbox"; cb.checked = !!fxo.fixed;
          cb.onchange = ()=>{
            state.meals[key].fixed = state.meals[key].fixed || {};
            const currentV = (gIn.value||'').replace(',', '.');
            const n = isFinite(parseFloat(currentV)) ? Math.max(parseFloat(currentV),0) : gCalc;
            state.meals[key].fixed[ing.id] = { g:n, fixed: cb.checked };
            save();
            solveMeal(key); renderMeals(); renderDailyTotals();
          };
          tdFix.appendChild(cb);

          const tdC = document.createElement("td"); tdC.className="right"; tdC.textContent = fmt(m.c,1);
          const tdP = document.createElement("td"); tdP.className="right"; tdP.textContent = fmt(m.p,1);
          const tdF = document.createElement("td"); tdF.className="right"; tdF.textContent = fmt(m.f,1);
          const tdK = document.createElement("td"); tdK.className="right"; tdK.textContent = fmt(kcal(m),0);
          const tdKL = document.createElement("td"); tdKL.className="right kcalLabelCell";
          const kLab100 = kcalLabel100(ing.per100);
          const kLab = (kLab100/100) * gCurrent;
          tdKL.textContent = fmt(kLab,0);

          tr.appendChild(tdN); tr.appendChild(tdG); tr.appendChild(tdFix); tr.appendChild(tdC); tr.appendChild(tdP); tr.appendChild(tdF); tr.appendChild(tdK); tr.appendChild(tdKL);
          tbody.appendChild(tr);
        });

        table.appendChild(tbody);
        card.appendChild(table);

        const totals = st.solution ? st.solution.achieved : {c:0,p:0,f:0};
        let kcalLabelTotal = 0;
        try {
          if (st.solution && st.solution.grams){
            rec.ingredients.forEach(ing=>{
              const g = st.solution.grams[ing.id] || 0;
              kcalLabelTotal += (kcalLabel100(ing.per100)/100) * g;
            });
          }
        } catch(e){}
              const totalsRow = document.createElement("div");
        totalsRow.className = "small";
        totalsRow.style.marginTop = "6px";

        if (st.solution) {
          const ok = toleranceOK(target, totals, getMealTol(key));

          const withinTol = t("dailyTotals.totalWithinTol", {
            pct: getMealTolPct(key)
          });
          const outOfTol = t("dailyTotals.totalOutOfTol", {
            pct: getMealTolPct(key)
          });

          const mealTotalsLabel = t("dailyTotals.mealTotalsLabel");
          const strictTag       = t("dailyTotals.strictEqualTag");

          totalsRow.innerHTML =
            `${mealTotalsLabel} — C ${fmt(totals.c)} / P ${fmt(totals.p)} / F ${fmt(totals.f)} ` +
            `— kcal ${fmt(kcal(totals), 0)} <span class="tag">${strictTag}</span> ` +
            (ok
              ? `<span class="pill ok">${withinTol}</span>`
              : `<span class="pill bad">${outOfTol}</span>`);
        } else {
          const hint = t("dailyTotals.mealRecalcHint");
          totalsRow.innerHTML = `<span class="muted">${hint}</span>`;
        }


if (st.solution){
          const infoRow = document.createElement("div");
          infoRow.className = "small labelKcalInfo";
          const delta = Math.round((kcalLabelTotal - kcal(totals))*1)/1;
          const sign = delta > 0 ? "+" : "";
            infoRow.textContent = t("dailyTotals.kcalLabelInfoDynamic", { labelKcal: fmt(kcalLabelTotal, 0),  delta: fmt(delta, 0),   sign  });
          card.appendChild(infoRow);
        }
                card.appendChild(totalsRow);
      }

      mealsRoot.appendChild(card);
    });
  }

  function computeDailyTotals(){

  let __balancing = false;
  function rebalanceRemainingMeals(changedMealKey){
    if (__balancing) return;
    __balancing = true;
    try {
      const day = (typeof selectedDayKey!=='undefined' ? selectedDayKey : 'mon');
      state.dynamicTargetsByDay = state.dynamicTargetsByDay || {};
      state.dynamicTargetsByDay[day] = state.dynamicTargetsByDay[day] || {};

      const keys = ["breakfast","lunch","snack","dinner"];
      const achieved = keys.reduce((acc,k)=>{
        const st = state.meals[k];
        if (st && st.solution){
          acc.c += st.solution.achieved.c;
          acc.p += st.solution.achieved.p;
          acc.f += st.solution.achieved.f;
        }
        return acc;
      }, {c:0,p:0,f:0});

      const rem = {
        c: Math.max(0, state.daily.c - achieved.c),
        p: Math.max(0, state.daily.p - achieved.p),
        f: Math.max(0, state.daily.f - achieved.f),
      };

      const flex = keys.filter(k=>{
        const st = state.meals[k];
        return (!st.locked) && (k !== changedMealKey);
      });

      if (flex.length === 0){
        save();
        return;
      }

      const totalPct = flex.reduce((s,k)=> s + (state.perc[k]||0), 0) || 1;
      const weight = (k)=> (state.perc[k]||0)/totalPct;

      flex.forEach(k=>{
        const share = weight(k);
        state.dynamicTargetsByDay[day][k] = {
          c: rem.c * share,
          p: rem.p * share,
          f: rem.f * share,
        };
      });

      if (changedMealKey){
        const st = state.meals[changedMealKey];
        if (st && st.solution){
          state.dynamicTargetsByDay[day][changedMealKey] = {
            c: st.solution.achieved.c,
            p: st.solution.achieved.p,
            f: st.solution.achieved.f,
          };
        }
      }

      flex.forEach(k=>{
        const st = state.meals[k];
        if (st && !st.locked){
          st.solution = null;
        }
      });

      save();
      autoSolveUnlocked();
      renderMeals();
      renderDailyTotals();
    } finally {
      __balancing = false;
    }
  }

    const keys = ["breakfast","lunch","snack","dinner"];
    return keys.reduce((acc,k)=>{
      const st = state.meals[k];
      if (st && st.solution){
        acc.c += st.solution.achieved.c;
        acc.p += st.solution.achieved.p;
        acc.f += st.solution.achieved.f;
      }
      return acc;
    }, {c:0,p:0,f:0});
  }

   function rebalanceRemainingMeals(changedMealKey){
       // V1: rebalance disattivato, ma la funzione esiste per evitare errori in console.
            return;
  }

  function renderDailyTotals(){
    const tgt = state.daily;
    const got = computeDailyTotals();
    const tK = kcal(tgt), gK = kcal(got);
    $("tgtC").textContent = fmt(tgt.c,1);
    $("tgtP").textContent = fmt(tgt.p,1);
    $("tgtF").textContent = fmt(tgt.f,1);
    $("tgtK").textContent = fmt(tK,0);
    $("gotC").textContent = fmt(got.c,1);
    $("gotP").textContent = fmt(got.p,1);
    $("gotF").textContent = fmt(got.f,1);
    $("gotK").textContent = fmt(gK,0);
    $("diffC").textContent = fmt(got.c - tgt.c,1);
    $("diffP").textContent = fmt(got.p - tgt.p,1);
    $("diffF").textContent = fmt(got.f - tgt.f,1);
    $("diffK").textContent = fmt(gK - tK,0);
    // Informational kcal from labels (per-ingredient kcal etichetta)
    let gKL = 0;
    try{
      ["breakfast","lunch","snack","dinner"].forEach(k=>{ const st = state.meals[k]; if(st && st.solution && typeof st.solution.kcalLabel!=="undefined"){ gKL += Number(st.solution.kcalLabel)||0; } });
    }catch(e){}
    const infoSpan = document.getElementById("labelKcalInfo");
    if (infoSpan){
  const dK = Math.round((gKL - gK)*1)/1;
  const s = dK > 0 ? "+" : "";
  infoSpan.textContent = t("dailyTotals.kcalLabelInfoDynamic", {
    labelKcal: fmt(gKL, 0),
    delta: fmt(dK, 0),
    sign: s
  });
}
    const lblK = document.getElementById("lblK"); if(lblK) lblK.textContent = fmt(gKL,0);
    const lblDK = document.getElementById("lblDK"); if(lblDK){ const d = Math.round((gKL - gK)*1)/1; const s2 = d>0?"+":""; lblDK.textContent = `${s2}${fmt(d,0)}`; }

    const tol = getTol();
    const within = (t,g)=> (t===0 ? Math.abs(g)<1e-3 : Math.abs(g-t) <= tol*Math.max(t,1e-6));
    const ok = within(tgt.c,got.c) && within(tgt.p,got.p) && within(tgt.f,got.f);
    const missingMeals = ["breakfast","lunch","snack","dinner"].filter(k=>!state.meals[k].solution).length;
    let html = "";
    if (missingMeals>0){
      html += `<span class="pill warn">${t("dailyTotals.missingMeals", { count: missingMeals })}</span> `;
    }
    html += ok
          ? `<span class="pill ok">${t("dailyTotals.totalWithinTol", { pct: getTolPct() })}</span>`
          : `<span class="pill bad">${t("dailyTotals.totalOutOfTol")}</span>`;

    $("dailyStatus").innerHTML = html;
  }

  

function solveMealSplit(mealKey){
  const st = state.meals[mealKey];
  if (!st || !st.split_v8 || !st.split_v8.enabled) return;

  const mode = st.split_v8.mode || 'percent';

  const primoSlot   = st.split_v8.primo   || {};
  const secondoSlot = st.split_v8.secondo || {};

  const recPrimo   = primoSlot.recipeId   ? state.recipes.find(r => r.id === primoSlot.recipeId)   : null;
  const recSecondo = secondoSlot.recipeId ? state.recipes.find(r => r.id === secondoSlot.recipeId) : null;

  if (!recPrimo && !recSecondo){
    st.solution = null;
    save();
    return;
  }

  const tgtPrimo   = recPrimo   ? __split_v8_target(mealKey, mode, primoSlot)   : {c:0,p:0,f:0};
  const tgtSecondo = recSecondo ? __split_v8_target(mealKey, mode, secondoSlot) : {c:0,p:0,f:0};

  const solvedPrimo = recPrimo
    ? __split_v8_solve(mealKey, recPrimo,  tgtPrimo)
    : { grams:{}, achieved:{c:0,p:0,f:0} };

  const solvedSecondo = recSecondo
    ? __split_v8_solve(mealKey, recSecondo, tgtSecondo)
    : { grams:{}, achieved:{c:0,p:0,f:0} };

  const grams = {};
  const mergedIngredients = [];
  const seen = {};

  function addFrom(rec, solved){
    if (!rec || !solved || !solved.grams) return;
    rec.ingredients.forEach(function(ing){
      const g = solved.grams[ing.id] || 0;
      if (!g) return;
      grams[ing.id] = (grams[ing.id] || 0) + g;
      if (!seen[ing.id]){
        seen[ing.id] = true;
        mergedIngredients.push(ing);
      }
    });
  }

  addFrom(recPrimo,   solvedPrimo);
  addFrom(recSecondo, solvedSecondo);

  const achieved = sumMacros(mergedIngredients, grams);

  const tgtMeal = targetFor(mealKey);
  const ok = toleranceOK(tgtMeal, achieved, getMealTol(mealKey));

  let kcalLabelSum;
  try{
    let s = 0;
    mergedIngredients.forEach(function(ing){
      const g = grams[ing.id] || 0;
      s += (kcalLabel100(ing.per100)/100) * g;
    });
    kcalLabelSum = Math.round(s * 1) / 1;
  } catch(e){
    kcalLabelSum = kcal(achieved);
  }

  st.solution = {
    grams: grams,
    achieved: achieved,
    kcal: kcal(achieved),
    kcalLabel: kcalLabelSum,
    ok: ok,
    split_v8: {
      mode: mode,
      primo: {
        recipeId: primoSlot.recipeId || null,
        grams: solvedPrimo.grams || {},
        achieved: solvedPrimo.achieved || {c:0,p:0,f:0}
      },
      secondo: {
        recipeId: secondoSlot.recipeId || null,
        grams: solvedSecondo.grams || {},
        achieved: solvedSecondo.achieved || {c:0,p:0,f:0}
      }
    }
  };

  save();
  try { writeMealToPlanner(mealKey); } catch(e) {}
  try { rebalanceRemainingMeals(mealKey); } catch(e) {
    if (typeof console !== 'undefined' && console && console.warn){
      console.warn('[Balance split]', e);
    }
  }
}

function solveMeal(mealKey){
  const st = state.meals[mealKey];
  if (!st) return;

  if (st.split_v8 && st.split_v8.enabled){
    solveMealSplit(mealKey);
    return;
  }

  if (!st.recipeId) return;
  const rec = state.recipes.find(r=>r.id===st.recipeId);
  if (!rec) return;
  const tgt = baseTargetFor(mealKey);

  st.fixed = st.fixed || {};
  if (rec && rec.ingredients){
    rec.ingredients.forEach(ing=>{
      if (!st.fixed[ing.id] || !st.fixed[ing.id].fixed){
        const ov = getFixedDefaultForMeal(ing, mealKey);
        if (ov){ st.fixed[ing.id] = ov; }
      }
    });
  }

  const fx = (st.fixed || {});
  const fixedIds = Object.keys(fx).filter(id => fx[id] && fx[id].fixed);
  const fixedIngs = rec.ingredients.filter(ing => fixedIds.includes(ing.id));
  const freeIngs  = rec.ingredients.filter(ing => !fixedIds.includes(ing.id));

  const fixedGrams = {};
  fixedIngs.forEach(ing => {
    const g = fx[ing.id] && typeof fx[ing.id].g !== "undefined" ? toNum(fx[ing.id].g) : 0;
    fixedGrams[ing.id] = Math.max(0, g);
  });
  const fixedMacros = sumMacros(fixedIngs, fixedGrams);

  const adjTarget = {
    c: Math.max(0, (tgt.c || 0) - (fixedMacros.c || 0)),
    p: Math.max(0, (tgt.p || 0) - (fixedMacros.p || 0)),
    f: Math.max(0, (tgt.f || 0) - (fixedMacros.f || 0)),
  };

  let solvedFree = {};
  if (freeIngs.length > 0){
    const ingsForSolver = freeIngs.map(ing=>({
      id: ing.id,
      per100: {
        c: ing.per100.c || 0,
        p: ing.per100.p || 0,
        f: ing.per100.f || 0
      }
    }));
    solvedFree = solveGrams(ingsForSolver, adjTarget);
  }

  const grams = {};
  fixedIngs.forEach(ing => { grams[ing.id] = fixedGrams[ing.id] || 0; });
  freeIngs.forEach(ing  => {
    const g = solvedFree[ing.id] || 0;
    grams[ing.id] = Math.max(0, toNum(g));
  });

  const achieved = sumMacros(rec.ingredients, grams);
  const ok = toleranceOK(tgt, achieved, getMealTol(mealKey));

  let kcalLabelSum;
  try{
    let s = 0;
    rec.ingredients.forEach(ing=>{
      const g = grams[ing.id] || 0;
      if (!g) return;
      const k100 = kcalLabel100(ing.per100 || {});
      s += (k100/100) * g;
    });
    kcalLabelSum = Math.round(s*1)/1;
  }catch(e){
    kcalLabelSum = kcal(achieved);
  }

  st.solution = {
    grams: grams,
    achieved: achieved,
    kcal: kcal(achieved),
    kcalLabel: kcalLabelSum,
    ok: ok
  };

  save();
  try { writeMealToPlanner(mealKey); } catch(e) {}
  try { rebalanceRemainingMeals(mealKey); } catch(e) {
    if (typeof console !== 'undefined' && console && console.warn){
      console.warn('[Balance]', e);
    }
  }
}

  function autoSolveUnlocked(){
    ["breakfast","lunch","snack","dinner"].forEach(k=>{
      const st = state.meals[k];
      if (!st.locked && st.recipeId){
        solveMeal(k);
      }
    });
  }

function solvePlannerCell(dayKey, mealKey){
  const dayState = ensureWeekPlanDay(dayKey);
  const cell = dayState[mealKey];
  const rec = state.recipes.find(r => r.id === cell.recipeId);
  if (!rec){ cell.solution = null; return; }

  // Target di base per il pasto (percentuali del giorno)
  const tgt = baseTargetFor(mealKey);

  // 1) Separazione ingredienti fissi di default e liberi
  const fixedIngs = [];
  const freeIngs  = [];
  const fixedGrams = {};

  rec.ingredients.forEach(ing => {
    const ov = getFixedDefaultForMeal(ing, mealKey);
    if (ov && ov.fixed){
      fixedIngs.push(ing);
      fixedGrams[ing.id] = Math.max(0, ov.g || 0);
    } else {
      freeIngs.push(ing);
    }
  });

  const fixedNames = fixedIngs.map(i => i.name);

  // 2) Contributo dei fissi e target residuo
  const fixedMacros = sumMacros(fixedIngs, fixedGrams);
  const adjTarget = {
    c: Math.max(0, (tgt.c || 0) - fixedMacros.c),
    p: Math.max(0, (tgt.p || 0) - fixedMacros.p),
    f: Math.max(0, (tgt.f || 0) - fixedMacros.f),
  };

  // 3) Risoluzione solo per ingredienti liberi
  let solvedFree = {};
  if (freeIngs.length > 0){
    solvedFree = solveGrams(freeIngs, adjTarget);
  }

  // 4) Unione grammi fissi + calcolati
  const grams = {};
  fixedIngs.forEach(ing => { grams[ing.id] = fixedGrams[ing.id] || 0; });
  freeIngs.forEach(ing  => { grams[ing.id] = Math.max(0, toNum(solvedFree[ing.id] || 0)); });

  // 5) Totali e tolleranza (usa quella globale per planner)
  const achieved = sumMacros(rec.ingredients, grams);
  const ok = toleranceOK(tgt, achieved, getTol());

  // 6) kcal etichetta (~) per coerenza con vista giornaliera
  let kcalLabelTotal = 0;
  try {
    rec.ingredients.forEach(ing => {
      const g = grams[ing.id] || 0;
      const kLab100 = kcalLabel100(ing.per100);
      kcalLabelTotal += (kLab100/100) * g;
    });
    kcalLabelTotal = Math.round(kcalLabelTotal * 1) / 1;
  } catch(e){ kcalLabelTotal = 4*achieved.c + 4*achieved.p + 9*achieved.f; }

  // 7) Snapshot per UI planner
  const snapshot = {
    items: (rec.ingredients || []).map(ing => ({
      id: ing.id,
      name: ing.name,
      grams: grams[ing.id] || 0
    }))
  };

  // 8) Salvataggio soluzione nella cella del planner
  cell.solution = {
    grams,
    achieved,
    kcal: 4*achieved.c + 4*achieved.p + 9*achieved.f,
    kcalLabel: kcalLabelTotal,
    ok,
    recipeName: rec.name,
    snapshot,
    hasFixedDefaults: fixedNames.length > 0,
    fixedNames
  };
}

function renderPlanner(){
    const root = $("planner");
    const table = document.createElement("table");
    table.className = "table";
    const thead = document.createElement("thead");
    const thr = document.createElement("tr");
        thr.innerHTML = ""
      + "<th>" + t("week.summaryHeaders.day") + "</th>"
      + "<th>" + t("week.summaryHeaders.breakfast") + "</th>"
      + "<th>" + t("week.summaryHeaders.lunch") + "</th>"
      + "<th>" + t("week.summaryHeaders.snack") + "</th>"
      + "<th>" + t("week.summaryHeaders.dinner") + "</th>";
    thead.appendChild(thr);
    table.appendChild(thead);
    const tbody = document.createElement("tbody");

    const dayDefs = [
      { key:"mon", label: t("days.mon") },
      { key:"tue", label: t("days.tue") },
      { key:"wed", label: t("days.wed") },
      { key:"thu", label: t("days.thu") },
      { key:"fri", label: t("days.fri") },
      { key:"sat", label: t("days.sat") },
      { key:"sun", label: t("days.sun") },
    ];

    dayDefs.forEach(d=>{
      const tr = document.createElement("tr");
      const dayTd = document.createElement("td"); dayTd.innerHTML = `<b>${d.label}</b>`; tr.appendChild(dayTd);
  ["breakfast","lunch","snack","dinner"].forEach(mk=>{
  const td = document.createElement("td");

  // usa sempre una dayState inizializzata
  const dayState = ensureWeekPlanDay(d.key);
  const cell = dayState[mk];
        const sel = document.createElement("select");
        const opt0 = document.createElement("option"); opt0.value=""; opt0.textContent="— Ricetta —";
        sel.appendChild(opt0);
        
state.recipes
  .filter(r => (r.allowedMeals ? !!r.allowedMeals[mk] : true))
  .slice()
  .sort((a,b)=> (a.name||"").localeCompare(b.name||""))
  .forEach(r=>{ const o=document.createElement("option"); o.value=r.id; o.textContent=r.name; sel.appendChild(o); });

        sel.value = cell.recipeId || "";
        sel.onchange = ()=>{ cell.recipeId = sel.value || null; cell.solution = null; save(); renderPlanner(); };
        td.appendChild(sel);
        if (cell.solution){
          const badge = document.createElement("div");
          badge.style.marginTop = "6px";
          badge.className = "small";
          badge.innerHTML = `<span class="tag">${cell.solution.recipeName}</span> ` +
            (cell.solution.ok ? `<span class="pill ok">ok</span>` : `<span class="pill bad">fuori tol.</span>`);
          td.appendChild(badge);
        }
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });

    table.appendChild(tbody);
    root.innerHTML = "";
    root.appendChild(table);
  }

  document.getElementById("solveWeekBtn").onclick = ()=>{
    ["mon","tue","wed","thu","fri","sat","sun"].forEach(d=> ["breakfast","lunch","snack","dinner"].forEach(mk=> solvePlannerCell(d, mk)));
    save(); renderPlanner();
    generateShoppingList();
  };
  document.getElementById("clearWeekBtn").onclick = ()=>{
    if (!confirm(t("dialogs.clearWeekSelectionsConfirm"))) return;
    ["mon","tue","wed","thu","fri","sat","sun"].forEach(d=> ["breakfast","lunch","snack","dinner"].forEach(mk=> state.weekPlan[d][mk] = { recipeId:null, solution:null }));
    save(); renderPlanner(); renderShoppingTable([]);
  };

  function generateShoppingList(){
    const totals = new Map();
    const dayDefs = ["mon","tue","wed","thu","fri","sat","sun"];
    dayDefs.forEach(d=>{
      ["breakfast","lunch","snack","dinner"].forEach(mk=>{
        const cell = state.weekPlan[d][mk];
        if (cell && cell.solution && cell.solution.grams){
          const rec = state.recipes.find(r=>r.id===cell.recipeId);
          if (!rec) return;
          rec.ingredients.forEach(ing=>{
            const g = cell.solution.grams[ing.id] || 0;
            if (g>0){
              const key = (ing.name||"").toLowerCase().trim();
              totals.set(key, (totals.get(key)||0) + g);
            }
          });
        }
      });
    });
    const rows = Array.from(totals.entries()).map(([key, g])=>{
      const lib = state.ingredientLibrary.find(i=>i.name.toLowerCase().trim()===key);
      const name = lib ? lib.name : (key.charAt(0).toUpperCase() + key.slice(1));
      return { name, grams: Math.round(g*10)/10, kg: Math.round((g/1000)*100)/100 };
    }).sort((a,b)=> a.name.localeCompare(b.name));
    renderShoppingTable(rows);
    return rows;
  }

  function renderShoppingTable(rows){
    const body = document.getElementById("shoppingBody");
    body.innerHTML = "";
    if (!rows || !rows.length){
      const tr = document.createElement("tr"); const td = document.createElement("td"); td.colSpan=4; td.className="small muted"; td.textContent="Nessun ingrediente (seleziona ricette e ricalcola la settimana)."; tr.appendChild(td); body.appendChild(tr); return;
    }
    rows.forEach(r=>{
      const tr = document.createElement("tr");
      const tdN = document.createElement("td"); tdN.textContent = r.name;
      const tdG = document.createElement("td"); tdG.className="right"; tdG.textContent = fmt(r.grams,1);
      const tdK = document.createElement("td");  tdK.className = "right";             // niente valore iniziale: lo mettiamo solo se troviamo packSize

      const tdPacks = document.createElement("td"); tdPacks.className="right";
         try {
      const lib = (state.ingredientLibrary || [])
        .find(i => (i.name || "").toLowerCase().trim() === (r.name || "").toLowerCase().trim());

      if (lib && lib.packSize){
        const pack = Number(lib.packSize) || 0;

        // Colonna "(g) x conf" → grammi per confezione
        tdK.textContent = pack ? fmt(pack, 0) : "—";

        // Colonna "Conf. (~)" → quante confezioni servono
        const num = Math.ceil((Number(r.grams) || 0) / (pack || 1));
        tdPacks.textContent = String(num);
      } else {
        tdK.textContent = "—";
        tdPacks.textContent = "—";
      }
    } catch(e){
      tdK.textContent = "—";
      tdPacks.textContent = "—";
    }

      tr.appendChild(tdN); tr.appendChild(tdG); tr.appendChild(tdK); tr.appendChild(tdPacks);
      body.appendChild(tr);
    });
  }

  document.getElementById("genListBtn").onclick = ()=>{ generateShoppingList(); };
document.getElementById("exportCSVBtn").onclick = ()=>{
  const rows = generateShoppingList();
  if (!rows.length){ alert(t("alerts.emptyList")); return; }

  const header = t("shopping.csvHeader");
  const lines = rows.map(r=>{
    const lib = (state.ingredientLibrary || []).find(
      i => (i.name||"").toLowerCase().trim() === (r.name||"").toLowerCase().trim()
    );
    const conf = (lib && lib.packSize)
      ? Math.ceil((Number(r.grams) || 0) / lib.packSize)
      : "";
    return `${r.name},${r.grams},${r.kg},${conf}`;
  });

  const csv = [header, ...lines].join("\n");
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = t("shopping.csvFilename");
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
};


  document.getElementById("exportBtn").onclick = ()=>{
    const blob = new Blob([JSON.stringify(state,null,2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = "macro_recipes_weekly_v7.json";
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  };
document.getElementById("importInput").onchange = (e)=>{
  const f = e.target.files && e.target.files[0];
  if (!f) return;

  const reader = new FileReader();
  reader.onload = ()=>{
    try {
      const data = JSON.parse(String(reader.result));
      if (data.daily && data.perc && data.recipes){
        Object.assign(state, data);   // ✅ FIX
        state.ingredientLibrary = data.ingredientLibrary || state.ingredientLibrary || buildLibraryFromRecipes(state.recipes);
        if (!data.weekPlan){
          state.weekPlan = JSON.parse(JSON.stringify(state.weekPlan));
        }
        Object.keys(state.meals).forEach(k=>{ state.meals[k].fixed = state.meals[k].fixed || {}; });
        dailyC.value = state.daily.c; 
        dailyP.value = state.daily.p; 
        dailyF.value = state.daily.f;
        dailyKcal.value = fmt(kcal(state.daily),0);
        pctBreakfast.value = state.perc.breakfast; 
        pctLunch.value = state.perc.lunch; 
        pctSnack.value = state.perc.snack; 
        pctDinner.value = state.perc.dinner;
        renderPercStatus();
        renderRecipes();
        renderMeals();
        renderPlanner();
        renderDailyTotals();
        save();
      } else {
         alert(t("alerts.fileInvalid"));
      }
    } catch(err){
      alert(t("alerts.fileReadError"));
    }
  };

  // 🔹 senza questo il reader non parte mai
  reader.readAsText(f);
};


document.getElementById("newRecipeBtn").onclick = ()=>{
  const name = prompt(t("dialogs.recipeName"));
  if (!name) return;
  state.recipes.push({ id: uid(), name, ingredients: [], open: true, description: "" });
  save(); renderRecipes(); renderMeals(); renderPlanner(); renderDailyTotals();
};

// ===============================
// PHOTO IMPORT (V1) - UI + manual create (no OCR yet)
// ===============================
function __tr(key, fallback, vars){
  try { return (typeof t === "function") ? t(key, vars || {}) : (fallback || key); }
  catch(e){ return fallback || key; }
}

function openPhotoImportModal(){
  const m = document.getElementById("photoImportModal");
  if (m) m.style.display = "flex";
}
function closePhotoImportModal(){
  const m = document.getElementById("photoImportModal");
  if (m) m.style.display = "none";
}
function resetPhotoImportForm(){
  const err = document.getElementById("photoImportErr");
  if (err){ err.style.display="none"; err.textContent=""; }

  const img = document.getElementById("photoImportPreview");
  const no  = document.getElementById("photoImportNoPreview");
  if (img){ img.src=""; img.style.display="none"; }
  if (no) no.style.display="block";

  ["photoImportName","photoImportC","photoImportP","photoImportF","photoImportKcal"].forEach(id=>{
    const el = document.getElementById(id);
    if (el) el.value = "";
  });
}
function showPhotoImportError(key){
  const err = document.getElementById("photoImportErr");
  if (!err) return;
  err.textContent = __tr(key || "recipes.photoImport.errGeneric", "Error");
  err.style.display = "block";
}

function getOpenRecipeOrWarn(){
  const open = (state.recipes || []).find(r => r && r.open);
  if (!open){
    showPhotoImportError("recipes.photoImport.errNoOpenRecipe");
    return null;
  }
  return open;
}

function toNumSafe(v){
  const n = parseFloat(String(v||"").trim().replace(",", "."));
  return Number.isFinite(n) ? n : NaN;
}
function clamp01_100(x){ return Math.max(0, Math.min(100, x)); }

 function photoImportSetMsg(kind, key, fallback){
  const el = document.getElementById("photoImportErr");
  if (!el) return;
  el.style.display = "block";
  el.style.color = (kind === "err") ? "var(--bad)" : "var(--muted)";
  el.textContent = __tr(key, fallback || key);
}

function readFileAsDataURL(file){
  return new Promise((resolve, reject)=>{
    const r = new FileReader();
    r.onload = ()=> resolve(String(r.result || ""));
    r.onerror = ()=> reject(r.error || new Error("FileReader error"));
    r.readAsDataURL(file);
  });
}

async function photoImportOcrFromApi(file){
  // status
  photoImportSetMsg("info", "recipes.photoImport.statusReading", "Reading label…");

  const dataUrl = await readFileAsDataURL(file);

  const resp = await fetch("/.netlify/functions/ocr-label", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ image: dataUrl })
  });

  let payloadText = "";
try { payloadText = await resp.text(); } catch(e){ payloadText = ""; }

if (!resp.ok){
  // prova a mostrare l'errore che la function ritorna
  let msg = "OCR HTTP " + resp.status;
  try {
    const j = JSON.parse(payloadText || "{}");
    if (j && j.error) msg += " — " + j.error;
    if (j && j.detail) msg += " — " + String(j.detail).slice(0,200);
  } catch(e){}
  photoImportSetMsg("err", "recipes.photoImport.errOcrFailed", msg);
  throw new Error(msg);
}

// se ok, parse JSON (riusando payloadText)
return JSON.parse(payloadText || "{}");

}

function photoImportApplyOcrResult(data){
  // Se l'API non ritorna macro, non inventiamo niente
  const per100 = data && data.per100 ? data.per100 : null;

  const nameEl = document.getElementById("photoImportName");
  const cEl = document.getElementById("photoImportC");
  const pEl = document.getElementById("photoImportP");
  const fEl = document.getElementById("photoImportF");
  const kEl = document.getElementById("photoImportKcal");

  if (nameEl && !nameEl.value && data && data.nameGuess) nameEl.value = data.nameGuess;

console.log("[OCR DEBUG] rawText:", data?.rawText);
console.log("[OCR DEBUG] per100:", data?.per100, "confidence:", data?.confidence);


  if (per100){
    if (cEl && Number.isFinite(per100.c)) cEl.value = String(per100.c);
    if (pEl && Number.isFinite(per100.p)) pEl.value = String(per100.p);
    if (fEl && Number.isFinite(per100.f)) fEl.value = String(per100.f);
    if (kEl && Number.isFinite(per100.kcalLabel)) kEl.value = String(per100.kcalLabel);
  }

  // Messaggio finale
  const conf = (data && Number.isFinite(data.confidence)) ? data.confidence : null;

  if (!per100){
    photoImportSetMsg("err", "recipes.photoImport.errOcrNoMacros", "I couldn’t read the macros. Please enter them manually.");
    return;
  }

  if (conf !== null && conf < 0.65){
    photoImportSetMsg("info", "recipes.photoImport.warnOcrLowConfidence", "I read the label, but please double-check the values.");
    return;
  }

  // ok: nascondo il messaggio
  const el = document.getElementById("photoImportErr");
  if (el){ el.style.display = "none"; el.textContent = ""; }
}


(function wirePhotoImport(){
  const btnTop  = document.getElementById("photoImportBtn");
  const inp     = document.getElementById("photoImportInput");
  const btnPick = document.getElementById("photoImportPickBtn");
  const btnClose= document.getElementById("photoImportCloseBtn");
  const backdrop= document.getElementById("photoImportModal");

  if (btnTop) btnTop.addEventListener("click", function(){
    resetPhotoImportForm();
    openPhotoImportModal();
    if (inp){ inp.value=""; inp.click(); }
  });

  if (btnPick) btnPick.addEventListener("click", function(){
    resetPhotoImportForm();
    openPhotoImportModal();
    if (inp){ inp.value=""; inp.click(); }
  });

  if (btnClose) btnClose.addEventListener("click", closePhotoImportModal);

  if (backdrop) backdrop.addEventListener("click", function(e){
    if (e.target === backdrop) closePhotoImportModal();
  });

if (inp) inp.addEventListener("change", function(e){
  const f = e.target.files && e.target.files[0];
  if (!f) return;

  const img = document.getElementById("photoImportPreview");
  const no  = document.getElementById("photoImportNoPreview");
  const url = URL.createObjectURL(f);

  if (img){
    img.src = url;
    img.style.display = "block";
    img.onload = ()=> URL.revokeObjectURL(url);
  }
  if (no) no.style.display = "none";

  photoImportOcrFromApi(f)
    .then(photoImportApplyOcrResult)
    .catch(err=>{
      console.warn(err);
      photoImportSetMsg(
        "err",
        "recipes.photoImport.errOcrFailed",
        "OCR failed. Please enter macros manually."
      );
    });
});


  const confirmBtn = document.getElementById("photoImportConfirmBtn");
  if (confirmBtn) confirmBtn.addEventListener("click", function(){
    const rec = getOpenRecipeOrWarn();
    if (!rec) return;

    const name = (document.getElementById("photoImportName")?.value || "").trim();
    const c = toNumSafe(document.getElementById("photoImportC")?.value);
    const p = toNumSafe(document.getElementById("photoImportP")?.value);
    const f = toNumSafe(document.getElementById("photoImportF")?.value);
    const kcalLbl = toNumSafe(document.getElementById("photoImportKcal")?.value);

    if (!name){
      showPhotoImportError("recipes.photoImport.errMissingName");
      return;
    }
    if (![c,p,f].every(x => Number.isFinite(x))){
      showPhotoImportError("recipes.photoImport.errInvalidMacros");
      return;
    }

    // STEP 4 validation (built-in)
    if ((c + p + f) > 120){
      showPhotoImportError("recipes.photoImport.errSumTooHigh");
      return;
    }

    const ing = {
      id: uid(),
      name: name,
      per100: { c: clamp01_100(c), p: clamp01_100(p), f: clamp01_100(f) }
    };
    if (Number.isFinite(kcalLbl) && kcalLbl > 0){
      ing.per100.kcalLabel = Math.max(0, kcalLbl);
    }

    rec.ingredients = rec.ingredients || [];
    rec.ingredients.push(ing);

    state.ingredientLibrary = state.ingredientLibrary || [];
    state.ingredientLibrary.push({
      id: ing.id,
      name: ing.name,
      per100: Object.assign({}, ing.per100)
    });

    save();
    renderRecipes();
    renderMeals();
    renderPlanner();
    renderDailyTotals();

    closePhotoImportModal();
  });
})();


  // --- TOLLERANZA CONFIGURABILE ---
if (typeof state.tolerance !== "number") {
  state.tolerance = 0.05;
  save();
}
const tolInput = document.getElementById("tolInput");
if (tolInput){
  tolInput.value = Math.round(state.tolerance * 1000) / 10;

  tolInput.addEventListener("input", ()=>{
    const v = Math.max(0, Math.min(50, parseFloat(tolInput.value || 0)));
    state.tolerance = isFinite(v) ? v/100 : 0.05;

    // salvataggio locale
    save();

    // salvataggio (debounced) su Supabase
    scheduleSaveSettings();

    renderMeals();
    renderDailyTotals();
    renderPlanner();

    const note = document.getElementById("toleranceNote");
    if (note) {
        note.innerHTML = t("misc.toleranceNote", { pct: getTolPct() }) +
    '<br><span id="labelKcalInfo" class="small labelKcalInfo"></span>';
    }
  });

  const note = document.getElementById("toleranceNote");
  if (note) {
      note.innerHTML = t("misc.toleranceNote", { pct: getTolPct() }) +
    '<br><span id="labelKcalInfo" class="small labelKcalInfo"></span>';
  }
}

  // --- Init selettore giorno ---
  function dateToDayKey(d){ const wd = d.getDay(); return ['sun','mon','tue','wed','thu','fri','sat'][wd]; }
  function dayKeyToLabel(k){ return t("days." + k) || k; }
  function formatISO(d){ const z = (n)=> String(n).padStart(2,'0'); return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`; }
  var selectedDate = new Date();
  var selectedDayKey = dateToDayKey(selectedDate);
  function setSelectedDate(d){ selectedDate = d; selectedDayKey = dateToDayKey(d); const dayPicker = document.getElementById('dayPicker'); const dayLabel = document.getElementById('dayLabel'); if (dayPicker) dayPicker.value = formatISO(d); if (dayLabel) dayLabel.textContent = `${dayKeyToLabel(selectedDayKey)}`; }
function syncMealsFromPlanner(){
  const day = (typeof selectedDayKey !== "undefined" && selectedDayKey) ? selectedDayKey : "mon";
  ['breakfast','lunch','snack','dinner'].forEach(k=>{
    const dayState = ensureWeekPlanDay(day);
    const cell = dayState[k] || { recipeId: null, solution: null };
    const st = state.meals[k];
    st.recipeId = cell.recipeId || null;
    st.fixed = {};

    if (st.recipeId){
      const rec = state.recipes.find(r=>r.id===st.recipeId);

      // 1) Precarica i default fissi dalla ricetta (se definiti)
      if (rec && rec.ingredients){
        rec.ingredients.forEach(ing=>{
          const dq = (typeof ing.defaultQty!=="undefined") ? Number(String(ing.defaultQty).replace(',','.')) : 0;
          if (ing.defaultFixed && dq>0){
            st.fixed[ing.id] = { g: dq, fixed: true };
          }
        });
      }

      // 2) Sovrappone i grammi pianificati dal planner
      const gramsPlanned = (cell.solution && cell.solution.grams) ? cell.solution.grams : null;
      const snapItems = (cell.solution && cell.solution.snapshot && Array.isArray(cell.solution.snapshot.items)) ? cell.solution.snapshot.items : null;

      if (rec && (gramsPlanned || snapItems)){
        const plannedById = gramsPlanned || {};
        const plannedByName = {};
        if (snapItems){
          snapItems.forEach(it=>{
            const key = (it && it.name ? it.name.toLowerCase().trim() : "");
            if (key) plannedByName[key] = Number(it.grams)||0;
          });
        }

        rec.ingredients.forEach(ing=>{
          // Prefer exact ID match
          let g = plannedById[ing.id];
          if (typeof g==="undefined"){
            // Fallback: match by snapshot name (case-insensitive)
            const key = (ing.name||"").toLowerCase().trim();
            if (key && typeof plannedByName[key]!=="undefined"){
              g = plannedByName[key];
            }
          }
          const val = Number(g)||0;
          if (val>0){ st.fixed[ing.id] = { g: val, fixed: true }; }
        });
      }
    }

    st.locked = false;
    st.solution = null;
  });
  save(); autoSolveUnlocked(); renderMeals(); renderDailyTotals();
}
function writeMealToPlanner(mealKey){
  const day = selectedDayKey;
  const st = state.meals[mealKey];

  // assicura che la giornata esista nella weekPlan
  const dayState = ensureWeekPlanDay(day);
  const cell = dayState[mealKey];

  if (cell){
    cell.recipeId = st.recipeId || null;
    cell.solution = st.solution
      ? JSON.parse(JSON.stringify(st.solution))
      : null;
    save();
    renderPlanner();
  }
}
  setSelectedDate(new Date());
  const dayPicker = document.getElementById('dayPicker');
  const prevDayBtn = document.getElementById('prevDayBtn');
  const nextDayBtn = document.getElementById('nextDayBtn');
  const syncBtn = document.getElementById('syncFromPlannerBtn');
  if (dayPicker){ dayPicker.addEventListener('change', ()=>{ const d = new Date(dayPicker.value+'T00:00:00'); if (!isNaN(d)) { setSelectedDate(d); try{ if(state.dynamicTargetsByDay && state.dynamicTargetsByDay[selectedDayKey]) delete state.dynamicTargetsByDay[selectedDayKey]; }catch(e){}; syncMealsFromPlanner(); } }); }
  if (prevDayBtn){ prevDayBtn.addEventListener('click', ()=>{ const d = new Date(selectedDate); d.setDate(d.getDate()-1); setSelectedDate(d); try{ if(state.dynamicTargetsByDay && state.dynamicTargetsByDay[selectedDayKey]) delete state.dynamicTargetsByDay[selectedDayKey]; }catch(e){}; syncMealsFromPlanner(); }); }
  if (nextDayBtn){ nextDayBtn.addEventListener('click', ()=>{ const d = new Date(selectedDate); d.setDate(d.getDate()+1); setSelectedDate(d); try{ if(state.dynamicTargetsByDay && state.dynamicTargetsByDay[selectedDayKey]) delete state.dynamicTargetsByDay[selectedDayKey]; }catch(e){}; syncMealsFromPlanner(); }); }
  if (syncBtn){ syncBtn.addEventListener('click', syncMealsFromPlanner); }

  // --- Toggle vista ricette: Lista / Categorie ---
  const viewListBtn  = document.getElementById("viewListBtn");
  const viewCardsBtn = document.getElementById("viewCardsBtn");

  function updateRecipeViewButtons(){
    if (!viewListBtn || !viewCardsBtn) return;
    if (state.recipeViewMode === "cards") {
      viewCardsBtn.classList.add("active");
      viewListBtn.classList.remove("active");
    } else {
      viewListBtn.classList.add("active");
      viewCardsBtn.classList.remove("active");
    }
  }

  if (viewListBtn){
    viewListBtn.addEventListener("click", () => {
      state.recipeViewMode = "list";
      save();
      updateRecipeViewButtons();
      renderRecipes();
    });
  }

  if (viewCardsBtn){
    viewCardsBtn.addEventListener("click", () => {
      state.recipeViewMode = "cards";
      save();
      updateRecipeViewButtons();
      renderRecipes();
    });
  }

  // Allinea i bottoni allo stato corrente al primo load
  updateRecipeViewButtons();


  renderRecipes();
  renderMeals();
  renderPlanner();
  renderDailyTotals();
  save();

  // --- Auto Sync Today preference ---
  const autoChk = document.getElementById("autoSyncTodayChk");
  if (autoChk){ autoChk.checked = !!state.autoSyncToday; autoChk.addEventListener("change", ()=>{ state.autoSyncToday = !!autoChk.checked; save(); }); }

  // Button manual load
  const loadTodayBtn = document.getElementById("loadTodayBtn");
  if (loadTodayBtn){ loadTodayBtn.addEventListener("click", ()=>{ syncMealsFromPlanner(); save(); renderMeals(); renderDailyTotals();}); }

  // Auto on load if enabled
  try { if (state.autoSyncToday){ syncMealsFromPlanner(); } } catch(e){}


  const HISTORY_KEY = "macro-recipe-tool-history-v1";

  function getDailyKcalLabel(){
    try{
      let gKL = 0;
      ["breakfast","lunch","snack","dinner"].forEach(k=>{ const st = state.meals[k]; if(st && st.solution && typeof st.solution.kcalLabel!=="undefined"){ gKL += Number(st.solution.kcalLabel)||0; } });
      return gKL;
    }catch(e){ return 0; }
  }

  function saveDayToHistory(){
    const dateStr = (function(){
      const d = selectedDate || new Date();
      const z = (n)=> String(n).padStart(2,'0');
      return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`;
    })();

    const tgt = state.daily;
    const got = computeDailyTotals();
    const kTheo = 4*got.c + 4*got.p + 9*got.f;
    const kLbl = getDailyKcalLabel();
    const entry = {
      date: dateStr,
      c: Math.round(got.c*10)/10,
      p: Math.round(got.p*10)/10,
      f: Math.round(got.f*10)/10,
      kcal: Math.round(kTheo),
      kcalLabel: Math.round(kLbl),
      delta: Math.round((kLbl - kTheo)),
      note: ""
    };
    let arr = [];
    try{ arr = JSON.parse(localStorage.getItem(HISTORY_KEY)||"[]"); }catch(e){ arr=[]; }
    arr.push(entry);
    localStorage.setItem(HISTORY_KEY, JSON.stringify(arr));
    renderHistoryTable();
    alert(t("history.saveDaySuccess"));
  }

  function renderHistoryTable(){
    const body = document.getElementById("historyBody");
    if (!body) return;
    let arr = [];
    try{ arr = JSON.parse(localStorage.getItem(HISTORY_KEY)||"[]"); }catch(e){ arr=[]; }
    body.innerHTML = "";
    if (!arr.length){
      const tr = document.createElement("tr");
const td = document.createElement("td");
td.colSpan = 8;
td.className = "small muted";
td.textContent = t("history.emptyState");
tr.appendChild(td);
body.appendChild(tr);
return;
    }
    // Latest first
    arr.slice().reverse().forEach(row=>{
      const tr = document.createElement("tr");
      const tdD = document.createElement("td"); tdD.textContent = row.date;
      const tdC = document.createElement("td"); tdC.className="right"; tdC.textContent = fmt(row.c,1);
      const tdP = document.createElement("td"); tdP.className="right"; tdP.textContent = fmt(row.p,1);
      const tdF = document.createElement("td"); tdF.className="right"; tdF.textContent = fmt(row.f,1);
      const tdK = document.createElement("td"); tdK.className="right"; tdK.textContent = fmt(row.kcal,0);
      const tdKL = document.createElement("td"); tdKL.className="right kcalLabelCell"; tdKL.innerHTML = `<i>${fmt(row.kcalLabel,0)}</i>`;
      const tdDK = document.createElement("td"); tdDK.className="right kcalLabelCell"; tdDK.innerHTML = `<i>${row.delta>0?'+':''}${fmt(row.delta,0)}</i>`;
      const tdN = document.createElement("td"); tdN.textContent = row.note || "";
      tr.appendChild(tdD); tr.appendChild(tdC); tr.appendChild(tdP); tr.appendChild(tdF); tr.appendChild(tdK); tr.appendChild(tdKL); tr.appendChild(tdDK); tr.appendChild(tdN);
      body.appendChild(tr);
    });
  }

  function exportHistoryCSV(){
    let arr = [];
try {
  arr = JSON.parse(localStorage.getItem(HISTORY_KEY) || "[]");
} catch(e) {
  arr = [];
}

if (!arr.length){
  alert(t("alerts.historyEmpty"));
  return;
}

const headerStr = t("history.csvHeader");
const header = headerStr.split(",");

const rows = arr.map(r => [
  r.date,
  fmt(r.c,1),
  fmt(r.p,1),
  fmt(r.f,1),
  fmt(r.kcal,0),
  fmt(r.kcalLabel,0),
  (r.delta > 0 ? '+' : '') + fmt(r.delta,0),
  r.note || ""
]);

const csv = [header.join(","), ...rows.map(r => r.join(","))].join("\n");

const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
const url = URL.createObjectURL(blob);

const a = document.createElement("a");
a.href = url;
a.download = t("history.csvFilename");

document.body.appendChild(a);
a.click();
a.remove();

URL.revokeObjectURL(url);
}

  function openHistory(){ const m = document.getElementById("historyModal"); if (m){ renderHistoryTable(); m.style.display="flex"; } }
  function closeHistory(){ const m = document.getElementById("historyModal"); if (m){ m.style.display="none"; } }
  function clearHistory(){ if (!confirm(t("dialogs.clearHistoryStorageConfirm"))) return;
  localStorage.setItem(HISTORY_KEY, "[]"); renderHistoryTable(); }

  // Hook up buttons
  (function(){
    const hb = document.getElementById("historyBtn"); if (hb) hb.addEventListener("click", openHistory);
    const sh = document.getElementById("saveDayBtn"); if (sh) sh.addEventListener("click", saveDayToHistory);
    const eh = document.getElementById("exportHistoryBtn"); if (eh) eh.addEventListener("click", exportHistoryCSV);
    const ch = document.getElementById("clearHistoryBtn"); if (ch) ch.addEventListener("click", clearHistory);
    const xh = document.getElementById("closeHistoryBtn"); if (xh) xh.addEventListener("click", closeHistory);
    // Close on backdrop click
    const mb = document.getElementById("historyModal"); if (mb) mb.addEventListener("click", (e)=>{ if (e.target===mb) closeHistory(); });
  })();


  /* === History Upsert & Modal Wiring (Dana patch 2025-10-30) === */
  try { state.history = Array.isArray(state.history) ? state.history : []; } catch(e){ state.history = []; }

  function localISODate(d){
    // returns YYYY-MM-DD in local time
    const dt = d ? new Date(d) : new Date();
    dt.setMinutes(dt.getMinutes() - dt.getTimezoneOffset());
    return dt.toISOString().slice(0,10);
  }

  function collectDaySnapshot(){
    const got = computeDailyTotals();
    const kcalTheo = Math.round(kcal(got));
    // Sum kcal etichetta dai pasti, se disponibili
    let kcalLbl = 0;
    try {
      ["breakfast","lunch","snack","dinner"].forEach(k=>{
        const st = state.meals[k];
        if (st && st.solution && typeof st.solution.kcalLabel !== "undefined"){
          const v = Number(st.solution.kcalLabel) || 0;
          kcalLbl += v;
        }
      });
    } catch(e){}
    const delta = Math.round((kcalLbl - kcalTheo));
    return {
      date: localISODate(),
      c: Math.round(got.c*10)/10,
      p: Math.round(got.p*10)/10,
      f: Math.round(got.f*10)/10,
      kcal: kcalTheo,
      kcalLabel: Math.round(kcalLbl),
      delta: delta,
      note: "" // opzionale, in futuro possiamo raccoglierla da un input
    };
  }

  function upsertHistoryByDate(rec){
    state.history = state.history || [];
    const idx = state.history.findIndex(r => r && r.date === rec.date);
    if (idx >= 0){
      state.history[idx] = rec; // sovrascrivi
    } else {
      state.history.push(rec); // aggiungi
    }
    // ordina desc per data
    state.history.sort((a,b)=> (a.date < b.date ? 1 : (a.date > b.date ? -1 : 0)));
  }

  function renderHistory(){
    const body = document.getElementById("historyBody");
    if (!body) return;
    body.innerHTML = "";
    const rows = Array.isArray(state.history) ? state.history : [];
    if (!rows.length){
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 8;
      td.className = "small muted";
      td.textContent = t("history.emptyState");

      tr.appendChild(td); body.appendChild(tr); return;
    }
    rows.forEach(r=>{
      const tr = document.createElement("tr");
      function td(txt, cls){ const t=document.createElement("td"); if(cls) t.className=cls; t.textContent=txt; return t; }
      tr.appendChild(td(r.date));
      tr.appendChild(td(String(r.c ?? "-"), "right"));
      tr.appendChild(td(String(r.p ?? "-"), "right"));
      tr.appendChild(td(String(r.f ?? "-"), "right"));
      tr.appendChild(td(String(r.kcal ?? "-"), "right"));
      const lbl = (typeof r.kcalLabel !== "undefined") ? r.kcalLabel : "";
      tr.appendChild(td(String(lbl), "right kcalLabelCell"));
      const d = (typeof r.delta !== "undefined") ? r.delta : ((Number(lbl)||0) - (Number(r.kcal)||0));
      const sign = d>0?"+":"";
      tr.appendChild(td(sign + String(d), "right kcalLabelCell"));
      tr.appendChild(td(r.note || ""));
      body.appendChild(tr);
    });
  }

  // Wire buttons
  (function wireHistoryButtons(){
    const saveBtn = document.getElementById("saveDayBtn");
    if (saveBtn && !saveBtn.__wired){
      saveBtn.__wired = true;
      saveBtn.addEventListener("click", ()=>{
        const rec = collectDaySnapshot();
        upsertHistoryByDate(rec);
        save();
        renderDailyTotals();
        renderHistory();
        // piccolo feedback visivo
        try {
          saveBtn.disabled = true;
          setTimeout(()=> saveBtn.disabled = false, 300);
        } catch(e){}
      });
    }
    const openBtn = document.getElementById("historyBtn");
    const modal = document.getElementById("historyModal");
    const closeBtn = document.getElementById("closeHistoryBtn");
    const clearBtn = document.getElementById("clearHistoryBtn");
    const exportBtn = document.getElementById("exportHistoryBtn");

    function show(){ if(modal){ modal.style.display = "flex"; renderHistory(); } }
    function hide(){ if(modal){ modal.style.display = "none"; } }

    if (openBtn && !openBtn.__wired){ openBtn.__wired = true; openBtn.addEventListener("click", show); }
    if (closeBtn && !closeBtn.__wired){ closeBtn.__wired = true; closeBtn.addEventListener("click", hide); }
    if (modal && !modal.__wiredBackdrop){ modal.__wiredBackdrop = true; modal.addEventListener("click", (e)=>{ if(e.target===modal) hide(); }); }

    if (clearBtn && !clearBtn.__wired){
      clearBtn.__wired = true;
      clearBtn.addEventListener("click", ()=>{
        if (!confirm(t("dialogs.clearHistoryStateConfirm"))) return;
        state.history = [];
        save();
        renderHistory();
      });
    }

    if (exportBtn && !exportBtn.__wired){
      exportBtn.__wired = true;
      exportBtn.addEventListener("click", ()=>{
        const rows = Array.isArray(state.history) ? state.history : [];
        if (!rows.length){ alert(t("alerts.historyEmpty")); return; }
        const csvHeader = t("history.csvHeader");
        const lines = rows.map(r=>[r.date, r.c, r.p, r.f, r.kcal, (r.kcalLabel ?? ""), (r.delta ?? ((r.kcalLabel||0)-(r.kcal||0))), (r.note||"")].join(","));
        const csv = [csvHeader, ...lines].join("\\n");
        const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = t("history.csvFilename");
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      });
    }
  })();
  /* === end patch === */

   /*
  // --- Remote UI wiring ---
  document.addEventListener('DOMContentLoaded', ()=>{
    const input = document.getElementById('recipesUrl');
    const saveBtn = document.getElementById('saveUrl');
    const reloadBtn = document.getElementById('reloadData');
    if (input) input.value = DATA_URL;
    if (saveBtn) saveBtn.addEventListener('click', ()=>{
      const v = (document.getElementById('recipesUrl').value||'').trim();
      if (v){
                    DATA_URL = v;
                   localStorage.setItem(RECIPES_URL_KEY, v);
                   alert(t("alerts.urlSaved"));
               }
    });
    if (reloadBtn) reloadBtn.addEventListener('click', ()=> loadRemote());
    // Auto-load remoto disattivato
    // if (DATA_URL) loadRemote();
  });
    */

  // --- Protein-first refinement (lexicographic style) ---
  function refineProteinFirst(mealKey){
    const st = state.meals[mealKey];
    if (!st || !st.recipeId || !st.solution || !st.solution.grams) return;
    const rec = state.recipes.find(r=>r.id===st.recipeId);
    if (!rec) return;
    const tol = getMealTol(mealKey); // % banda legata alla Tolleranza pasto
    const tgt = baseTargetFor(mealKey);
    const fx = (st.fixed || {});
    const isFixed = (id)=> !!(fx[id] && fx[id].fixed);

    const per100 = {}; rec.ingredients.forEach(ing=> per100[ing.id] = ing.per100 );

    const totalsFrom = (gramsMap)=>Object.entries(gramsMap).reduce((acc,[id,g])=>{
      const p = per100[id]; if (!p) return acc;
      const k = (Number(g)||0)/100;
      acc.c += k*(p.c||0); acc.p += k*(p.p||0); acc.f += k*(p.f||0);
      return acc;
    }, {c:0,p:0,f:0});

    const grams = Object.assign({}, st.solution.grams||{});
    let cur = totalsFrom(grams);

    const bandP = (tol/100) * (tgt.p||1);
    const wantMinP = (tgt.p||0) - bandP;
    const wantMaxP = (tgt.p||0) + bandP;

    const freeIds = rec.ingredients.map(x=>x.id).filter(id=>!isFixed(id));

    const dens = id => {
      const p = per100[id]||{c:0,p:0,f:0};
      return {
        p100: (p.p||0),
        c100: (p.c||0),
        f100: (p.f||0),
        pPerAll: (p.p||0)/((p.c||0)+(p.f||0)+1e-6),
        cBias: (p.c||0) - 0.3*(p.p||0)
      };
    };
    const protSources = freeIds.slice().sort((a,b)=> dens(b).pPerAll - dens(a).pPerAll);
    const carbSources = freeIds.slice().sort((a,b)=> dens(b).cBias - dens(a).cBias);

    let safety = 0;
    const step = 10;
    while ((cur.p < wantMinP) && safety < 3000){
      safety++;
      const addId = protSources.find(id=>true);
      if (!addId) break;
      grams[addId] = (Number(grams[addId])||0) + step;

      cur = totalsFrom(grams);
      const cBand = (tol/100)*(tgt.c||1);
      if (cur.c > (tgt.c + cBand)){
        const subId = carbSources.find(id => (Number(grams[id])||0) > 0 && id !== addId);
        if (subId){
          grams[subId] = Math.max(0, (Number(grams[subId])||0) - step);
        }
      }
      cur = totalsFrom(grams);
      if (cur.p >= wantMinP && cur.p <= wantMaxP) break;
    }

    st.solution.grams = grams;
    st.solution.achieved = totalsFrom(grams);
    st.solution.kcal = kcal(st.solution.achieved);
    st.solution.ok = toleranceOK(tgt, st.solution.achieved, tol);
  }


  // --- Lexicographic refine: P first, then C, then F (kcal ignored) ---
  function refineProteinLexi(mealKey){
    const st = state.meals[mealKey];
    if (!st || !st.recipeId || !st.solution || !st.solution.grams) return;
    const rec = state.recipes.find(r=>r.id===st.recipeId);
    if (!rec) return;
    const tol = getMealTol(mealKey);
    const tgt = baseTargetFor(mealKey);
    const fx = (st.fixed || {});
    const isFixed = (id)=> !!(fx[id] && fx[id].fixed);
    const per100 = {}; rec.ingredients.forEach(ing=> per100[ing.id] = ing.per100 );

    const totalsFrom = (gramsMap)=>Object.entries(gramsMap).reduce((acc,[id,g])=>{
      const p = per100[id]; if (!p) return acc;
      const k = (Number(g)||0)/100;
      acc.c += k*(p.c||0); acc.p += k*(p.p||0); acc.f += k*(p.f||0);
      return acc;
    }, {c:0,p:0,f:0});

    const grams = Object.assign({}, st.solution.grams||{});
    let cur = totalsFrom(grams);

    const band = (x)=> (tol/100) * (x||1);
    const inBand = (val, target)=> Math.abs(val-target) <= band(target);

    const freeIds = rec.ingredients.map(x=>x.id).filter(id=>!isFixed(id));

    // Helpers to rank ingredients
    const rankProt = freeIds.slice().sort((a,b)=> (per100[b]?.p||0) - (per100[a]?.p||0));
    const rankProtLean = freeIds.slice().sort((a,b)=> {
      const pa = per100[a]||{p:0,c:0,f:0}, pb = per100[b]||{p:0,c:0,f:0};
      const sa = (pa.p||0)/((pa.c||0)+0.5*(pa.f||0)+1e-6);
      const sb = (pb.p||0)/((pb.c||0)+0.5*(pb.f||0)+1e-6);
      return sb - sa;
    });
    const rankCarbHeavy = freeIds.slice().sort((a,b)=> (per100[b]?.c||0) - (per100[a]?.c||0));
    const rankFatHeavy  = freeIds.slice().sort((a,b)=> (per100[b]?.f||0) - (per100[a]?.f||0));

    let safety = 0;
    const stepUp = 25, stepDown = 25;

    // 1) Push Proteins into band
    while (!inBand(cur.p, tgt.p) && safety < 5000){
      safety++;
      if (cur.p < tgt.p){
        // add lean protein
        const addId = rankProtLean.find(id=>true);
        if (!addId) break;
        grams[addId] = (Number(grams[addId])||0) + stepUp;
      } else {
        // too high protein: reduce the least protein-dense
        const cutId = freeIds.slice().sort((a,b)=> (per100[a]?.p||0) - (per100[b]?.p||0)).find(id=> (Number(grams[id])||0) > 0);
        if (!cutId) break;
        grams[cutId] = Math.max(0,(Number(grams[cutId])||0) - stepDown);
      }
      cur = totalsFrom(grams);
    }

    // 2) Control Carbs: try to not exceed band on C; prefer staying <= target if possibile
    const maxC = tgt.c + band(tgt.c);
    let guard = 0;
    while (cur.c > maxC && guard < 4000){
      guard++;
      // remove carb-heavy first
      const subId = rankCarbHeavy.find(id=> (Number(grams[id])||0) > 0);
      if (!subId) break;
      grams[subId] = Math.max(0,(Number(grams[subId])||0) - stepDown);
      cur = totalsFrom(grams);
      // if protein drops out of band, compensate with lean protein
      if (!inBand(cur.p, tgt.p)){
        const addId = rankProtLean.find(id=>true);
        if (addId){
          grams[addId] = (Number(grams[addId])||0) + stepUp;
          cur = totalsFrom(grams);
        }
      }
    }

    // 3) Control Fats (tertiary): keep within band if easy
    const maxF = tgt.f + band(tgt.f);
    let guardF = 0;
    while (cur.f > maxF && guardF < 2000){
      guardF++;
      const subIdF = rankFatHeavy.find(id=> (Number(grams[id])||0) > 0);
      if (!subIdF) break;
      grams[subIdF] = Math.max(0,(Number(grams[subIdF])||0) - stepDown);
      cur = totalsFrom(grams);
      if (!inBand(cur.p, tgt.p)){
        const addId = rankProtLean.find(id=>true);
        if (addId){
          grams[addId] = (Number(grams[addId])||0) + stepUp;
          cur = totalsFrom(grams);
        }
      }
    }

    st.solution.grams = grams;
    st.solution.achieved = totalsFrom(grams);
    st.solution.kcal = kcal(st.solution.achieved);
    st.solution.ok = toleranceOK(tgt, st.solution.achieved, tol);
  }


// === Split Primo/Secondo — helpers (v8 safe) ===


})();
</script>

<script>
// Chart.js dynamic loader if not present
(function(){
  function loadChartJs(cb){
    if (window.Chart) { cb && cb(); return; }
    var s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/chart.js';
    s.onload = cb;
    document.head.appendChild(s);
  }

  // minimal state bridge
    window.__pesoInit = function(){
    if (!window.state) return;
    if (!('pesoLog' in state)) state.pesoLog = [];
    if (!document.getElementById('weightCard')) return;

    // Assicuriamoci che le traduzioni del planner siano caricate
    try {
      if (typeof ensurePlannerTranslations === "function") {
        ensurePlannerTranslations().then(function () {
          loadChartJs(function () {
            try { __renderPeso(); } catch (e) { console.warn(e); }
          });
        });
        return;
      }
    } catch (e) {
      console.warn(e);
    }

    // Fallback se per qualche motivo ensurePlannerTranslations non esiste
    loadChartJs(function () {
      try { __renderPeso(); } catch (e) { console.warn(e); }
    });
  };


  var pesoChart = null;
  function __save(){ try{ localStorage.setItem("macro-recipe-tool-html-v7", JSON.stringify(state)); }catch(e){} }
  function __renderPeso(){
    var input = document.getElementById('pesoInput');
    var addBtn = document.getElementById('pesoAddBtn');
    var tbl = document.getElementById('pesoTable').querySelector('tbody');
    var note = document.getElementById('pesoDeltaNote');

    function renderTable(){
      var log = (state.pesoLog||[]).slice().sort(function(a,b){ return a.data.localeCompare(b.data); });
      var html = "";
      if(!log.length){
 html = '<tr><td colspan="3" class="small muted">' + t("weight.emptyState") + '</td></tr>';
      } else {
        log.forEach(function(r,i){
          html += '<tr>' +
                  '<td>'+ r.data +'</td>' +
                  '<td class="right">'+ Number(r.peso).toFixed(1) +'</td>' +
                  '<td class="right">' +
                  '<button class="btn-outline" data-edit="'+i+'">'+ t("weight.tableEditButton") +'</button> ' +
                                           '<button class="btn-outline" style="color:var(--bad)" data-del="'+i+'">'+ t("weight.tableDeleteButton") +'</button>' +
                  '</td>' +
                  '</tr>';
        });
      }
      tbl.innerHTML = html;
      // bind actions
    tbl.querySelectorAll('[data-edit]').forEach(function(btn){
  btn.addEventListener('click', function(){
    var idx = Number(this.getAttribute('data-edit'));

    // prendiamo il record dalla LISTA ORDINATA, come la tabella
    var rec = (state.pesoLog||[])
      .slice()
      .sort(function(a,b){ return a.data.localeCompare(b.data); })[idx];

    if (!rec) return;

    var nuovo = prompt(t("weight.editPrompt", { date: rec.data }), rec.peso);
    if (nuovo === null) return;

    var num = parseFloat(String(nuovo).replace(',', '.'));
    if (!isFinite(num) || num <= 0){
      alert(t("alerts.invalidValue"));
      return;
    }

    // aggiorna la entry ORIGINALE cercandola per data
    var found = (state.pesoLog || []).find(function(r){
      return r.data === rec.data;
    });

    if (found){
      found.peso = num;
      __save();
      renderAll();

      // aggiorna anche su Supabase, se presente
      if (typeof window.__plannerSaveWeight === "function") {
        try {
          window.__plannerSaveWeight(rec.data, num);
        } catch(e){
          console.warn("Errore update peso remoto:", e);
        }
      }
    }
  });
});


          tbl.querySelectorAll('[data-del]').forEach(function(btn){
        btn.addEventListener('click', function(){
          var idx = Number(this.getAttribute('data-del'));
          var rec = (state.pesoLog||[])
            .slice()
            .sort(function(a,b){ return a.data.localeCompare(b.data); })[idx];

          if (!rec) return;

          if (!confirm(t("dialogs.deleteWeightEntryConfirm", { date: rec.data }))) return;

          state.pesoLog = (state.pesoLog||[]).filter(function(x){
            return !(x.data === rec.data && Number(x.peso) === Number(rec.peso));
          });

          __save();
          renderAll();

          // 🔁 cancella anche da Supabase
          if (typeof window.__plannerDeleteWeight === "function") {
            try {
              window.__plannerDeleteWeight(rec.data);
            } catch(e){
              console.warn("Errore delete peso remoto:", e);
            }
          }
        });
      });

    }

    function renderChart(){
      var log = (state.pesoLog||[]).slice().sort(function(a,b){ return a.data.localeCompare(b.data); });
      var labels = log.map(r=>r.data);
      var values = log.map(r=>Number(r.peso));
      // delta 7gg
      if (values.length>=8){
        var delta7 = (values[values.length-1] - values[values.length-8]).toFixed(2);
        var deltaTxt = (delta7 > 0 ? '+' : '') + delta7;
        note.textContent = t("weight.delta7Label", { delta: deltaTxt });
      } else {
        note.textContent = '';
      }
      var ctx = document.getElementById('pesoChart').getContext('2d');
      if (pesoChart) { pesoChart.destroy(); pesoChart=null; }
      if (!window.Chart) return;
      pesoChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            { label: t("weight.chartLabel"), data: values, tension: 0.2 }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: { x: { ticks: { autoSkip:true, maxTicksLimit:8 } }, y: { beginAtZero: false } },
          plugins: { legend: { display: true } }
        }
      });
    }

    function renderAll(){
      renderTable();
      renderChart();
    }


// Evita di agganciare più volte lo stesso listener
if (!addBtn.dataset.bound) {
  addBtn.dataset.bound = "1";

  addBtn.addEventListener('click', function () {
    // prendo la stringa UNA volta sola
    var raw = String(input.value || '').trim().replace(',', '.');

    // se è vuota → non faccio nulla, niente popup
    if (!raw) return;

   var val = parseFloat(raw);

    if (!Number.isFinite(val) || val <= 0) {
      alert(t("weight.invalidInput"));
      return;
    }

    var today = new Date().toISOString().slice(0, 10);
    state.pesoLog = state.pesoLog || [];

    // prevent duplicates same day: replace existing
    var idx = state.pesoLog.findIndex(function (r) { return r.data === today; });
    if (idx >= 0) state.pesoLog[idx].peso = val;
    else state.pesoLog.push({ data: today, peso: val });

    state.pesoLog.sort(function (a, b) { return a.data.localeCompare(b.data); });
    input.value = '';
    __save();
    renderAll();

    // 🔁 Salva/aggiorna anche su Supabase
    if (typeof window.__plannerSaveWeight === "function") {
      try { window.__plannerSaveWeight(today, val); }
      catch (e) { console.warn("Errore salvataggio peso remoto:", e); }
    }
  });
}


// La tabella viene ridisegnata SEMPRE
renderAll();
} 

  // Hook on DOM ready to init panel
  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(function(){ try { window.__pesoInit(); } catch(e){} }, 0);
  });

})();
</script>

</div>
<script>
  // ==== Supabase Auth (email + password) + Sync planner_data ====

  const SUPABASE_URL = "https://micltiqgbzjofsajzgpo.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_xGB4pwmtMlsYDorVtK7NYw_hyi0pF0Q";
  const TABLE_PLANNER = "planner_data";
  const TABLE_SETTINGS = "settings";
  const TABLE_WEIGHTS = "weights";

  // Mappa dallo state JS alla riga della tabella settings
  function makeSettingsRow(userId){
    return {
      user_id: userId,

      // macro giornalieri in grammi
      daily_carb_g:    Math.round(state?.daily?.c ?? 330),
      daily_protein_g: Math.round(state?.daily?.p ?? 170),
      daily_fat_g:     Math.round(state?.daily?.f ?? 70),

      // percentuali per pasto (salvate come numeri, es 25, 35, 10, 30)
      breakfast_ratio: state?.perc?.breakfast ?? 25,
      lunch_ratio:     state?.perc?.lunch     ?? 35,
      snack_ratio:     state?.perc?.snack     ?? 10,
      dinner_ratio:    state?.perc?.dinner    ?? 30,

      // modalità strict-math (se non usata ancora, false)
      strict_math: !!state?.strictMath,

      // tolleranza in percentuale: state.tolerance è 0.05 → salvo 5
      tolerance_pct: (typeof state?.tolerance === "number"
        ? state.tolerance * 100
        : 5),

      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
  }

  // Applica una riga di settings allo state + UI
  function applySettingsRow(row){
    if (!row || !window.state) return;

    // 1) aggiorna state
    state.daily = state.daily || { c:330, p:170, f:70 };
    state.perc  = state.perc  || { breakfast:25, lunch:35, snack:10, dinner:30 };

    if (typeof row.daily_carb_g    === "number") state.daily.c = row.daily_carb_g;
    if (typeof row.daily_protein_g === "number") state.daily.p = row.daily_protein_g;
    if (typeof row.daily_fat_g     === "number") state.daily.f = row.daily_fat_g;

    if (typeof row.breakfast_ratio === "number") state.perc.breakfast = row.breakfast_ratio;
    if (typeof row.lunch_ratio     === "number") state.perc.lunch     = row.lunch_ratio;
    if (typeof row.snack_ratio     === "number") state.perc.snack     = row.snack_ratio;
    if (typeof row.dinner_ratio    === "number") state.perc.dinner    = row.dinner_ratio;

    if (typeof row.strict_math === "boolean") state.strictMath = row.strict_math;

    // DB tiene la tolleranza in percentuale → nello state vogliamo la frazione
    if (typeof row.tolerance_pct === "number"){
      const v = row.tolerance_pct;
      if (isFinite(v)) state.tolerance = Math.max(0, v) / 100;
    }

    // 2) aggiorna gli input a schermo
    try {
      const dailyC    = document.getElementById("dailyC");
      const dailyP    = document.getElementById("dailyP");
      const dailyF    = document.getElementById("dailyF");
      const dailyKcal = document.getElementById("dailyKcal");

      const pctBreakfast = document.getElementById("pctBreakfast");
      const pctLunch     = document.getElementById("pctLunch");
      const pctSnack     = document.getElementById("pctSnack");
      const pctDinner    = document.getElementById("pctDinner");

      const tolInput  = document.getElementById("tolInput");
      const autoChk   = document.getElementById("autoSyncTodayChk");
      const strictChk = document.getElementById("strictMathChk");

      if (dailyC) dailyC.value = state.daily.c;
      if (dailyP) dailyP.value = state.daily.p;
      if (dailyF) dailyF.value = state.daily.f;
      if (dailyKcal) dailyKcal.value = (4*state.daily.c + 4*state.daily.p + 9*state.daily.f).toFixed(0);

      if (pctBreakfast) pctBreakfast.value = state.perc.breakfast;
      if (pctLunch)     pctLunch.value     = state.perc.lunch;
      if (pctSnack)     pctSnack.value     = state.perc.snack;
      if (pctDinner)    pctDinner.value    = state.perc.dinner;

      if (tolInput && typeof state.tolerance === "number"){
        // nello state è frazione (0.05) → UI in % con una cifra decimale
        tolInput.value = Math.round(state.tolerance*1000)/10;
      }

      if (autoChk)   autoChk.checked   = !!state.autoSyncToday; // resta solo localStorage
      if (strictChk) strictChk.checked = !!state.strictMath;

    } catch(e){
      console.warn("applySettingsRow UI error", e);
    }

    // 3) ridisegna tutto
    try {
      if (typeof renderPercStatus === "function")   renderPercStatus();
      if (typeof renderMeals === "function")        renderMeals();
      if (typeof renderPlanner === "function")      renderPlanner();
      if (typeof renderDailyTotals === "function")  renderDailyTotals();
      if (typeof save === "function")               save();
    } catch(e){
      console.warn("applySettingsRow render error", e);
    }
  }

  // Salva/aggiorna i settings su Supabase
  async function saveSettingsToSupabase(){
    if (!currentUser || !currentUser.id) return;
    if (!supabaseClient) return;

    const payload = {
      user_id: currentUser.id,
      daily_carb_g:    Math.round(state.daily.c || 0),
      daily_protein_g: Math.round(state.daily.p || 0),
      daily_fat_g:     Math.round(state.daily.f || 0),

      breakfast_ratio: state.perc.breakfast ?? 0,
      lunch_ratio:     state.perc.lunch     ?? 0,
      snack_ratio:     state.perc.snack     ?? 0,
      dinner_ratio:    state.perc.dinner    ?? 0,

      strict_math: !!state.strictMath,

      tolerance_pct: (typeof state.tolerance === "number"
        ? state.tolerance * 100
        : 5),

      updated_at: new Date().toISOString()
    };

    try {
      const { error } = await supabaseClient
        .from(TABLE_SETTINGS)
        .upsert(payload, { onConflict: "user_id" });

      if (error){
        console.warn("Errore salvataggio settings Supabase:", error);
      } else {
        console.info("Settings salvati su Supabase.");
      }
    } catch(e){
      console.warn("Eccezione saveSettingsToSupabase:", e);
    }
  }

  // Debounce per non martellare Supabase
  let settingsSaveTimer = null;
  function scheduleSaveSettings(){
    if (!currentUser || !currentUser.id) return;
    clearTimeout(settingsSaveTimer);
    settingsSaveTimer = setTimeout(saveSettingsToSupabase, 800);
  }

  // Legge (o crea) i settings per l'utente loggato
  async function loadSettingsForCurrentUser(){
    if (!currentUser || !currentUser.id) return;

    try {
      const { data, error } = await supabaseClient
        .from(TABLE_SETTINGS)
        .select("*")
        .eq("user_id", currentUser.id)
        .maybeSingle();

      // Errore "vero"
      if (error && error.code !== "PGRST116") {
        console.warn("Errore lettura settings:", error);
        return;
      }

      // Nessuna riga esistente → crea con i valori locali attuali
      if (!data) {
        const row = makeSettingsRow(currentUser.id);
        const { error: insErr } = await supabaseClient
          .from(TABLE_SETTINGS)
          .insert(row);
        if (insErr) {
          console.warn("Errore insert settings:", insErr);
        } else {
          console.info("Settings creati per l'utente corrente.");
        }
        return;
      }

      // Applica la riga letta
      applySettingsRow(data);
    } catch(e){
      console.warn("loadSettingsForCurrentUser exception:", e);
    }
  }


  // client Supabase
  const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  let currentUser = null;
  let remoteSaveTimer = null;
  const REMOTE_SAVE_DELAY = 2000; // ms

  // --- UTIL UI ---

function getAuthEls() {
  return {
    emailInput:  document.getElementById("loginEmail"),
    passwordInput: document.getElementById("loginPassword"),
    loginBtn:    document.getElementById("loginBtn"),
    signupBtn:   document.getElementById("signupBtn"),
    logoutBtn:   document.getElementById("logoutBtn"),
    statusEl:    document.getElementById("loginStatus")
  };
}


  function setAuthStatus(msg, type = "info"){
    const { statusEl } = getAuthEls();
    if (!statusEl) return;
    statusEl.textContent = msg || "";
    statusEl.style.color =
      type === "error" ? "#b91c1c" :
      type === "success" ? "#166534" :
      "#6b7280";
  }

  function setAuthUILoggedIn(email){
  const { emailInput, passwordInput, loginBtn, logoutBtn } = getAuthEls();
  const authScreen = document.getElementById("auth-screen");
  const appRoot = document.getElementById("app-root");

  if (emailInput) emailInput.disabled = true;
  if (passwordInput) passwordInput.disabled = true;
  if (loginBtn) loginBtn.style.display = "none";
  if (logoutBtn) logoutBtn.style.display = "inline-flex";

  // 👉 switch di schermata
  if (authScreen) authScreen.style.display = "none";
  if (appRoot) appRoot.style.display = "block";

  setAuthStatus(email ? `Connesso come ${email}` : "Connesso", "success");
}

function setAuthUILoggedOut(){
  const { emailInput, passwordInput, loginBtn, logoutBtn } = getAuthEls();
  const authScreen = document.getElementById("auth-screen");
  const appRoot = document.getElementById("app-root");

  if (emailInput){ emailInput.disabled = false; emailInput.value = ""; }
  if (passwordInput){ passwordInput.disabled = false; passwordInput.value = ""; }
  if (loginBtn) loginBtn.style.display = "inline-flex";
  if (logoutBtn) logoutBtn.style.display = "none";

  // 👉 torna alla schermata di login
  if (authScreen) authScreen.style.display = "flex";
  if (appRoot) appRoot.style.display = "none";

  setAuthStatus("Non connesso", "info");
}
function buildIngredientLibraryFromRecipes(recs){
  const map = new Map();

  (recs || []).forEach(r => (r.ingredients || []).forEach(ing => {
    const key = (ing.name || "").toLowerCase().trim();
    if (!key) return;

    // estraggo l'eventuale packSize dalla ricetta
    let packSize = null;
    if (typeof ing.packSize !== "undefined" && ing.packSize !== null && ing.packSize !== ""){
      const v = Number(String(ing.packSize).replace(",", "."));
      if (isFinite(v) && v > 0) packSize = v;
    }

    const existing = map.get(key);

    if (!existing) {
      map.set(key, {
        id: ing.id || (
          (typeof crypto !== "undefined" && crypto.randomUUID)
            ? crypto.randomUUID()
            : ("ing-" + Math.random().toString(36).slice(2))
        ),
        name: ing.name,
        per100: { ...(ing.per100 || {}) },
        ...(packSize ? { packSize } : {})
      });
    } else {
      // se prima non avevo packSize e ora sì, lo aggiorno
      if (!existing.packSize && packSize){
        existing.packSize = packSize;
      }
      // opzionale: se vuoi, puoi anche fondere eventuali per100 mancanti
      if (ing.per100){
        existing.per100 = existing.per100 || {};
        for (const k in ing.per100){
          if (existing.per100[k] == null || existing.per100[k] === ""){
            existing.per100[k] = ing.per100[k];
          }
        }
      }
    }
  }));

  return Array.from(map.values());
}



  // --- LOAD planner_data da Supabase ---

async function loadPlannerFromSupabase() {
  if (!currentUser || !supabaseClient) return;

  let stateLocal = null;
  let row = null;
  let nextState = null;

  try {
    // 1. Leggo il planner remoto
    const { data, error } = await supabaseClient
      .from(TABLE_PLANNER)
      .select("id, recipes, planner_week")
      .eq("user_id", currentUser.id)
      .maybeSingle();

    if (error && error.code !== "PGRST116") {
      console.warn("Supabase load error", error);
      if (typeof window.showToast === "function") {
        window.showToast("⚠️ Errore caricando il planner", "error");
      }
      return;
    }

    row = data || null;

    // 2. Provo a leggere lo stato locale (vecchio v7)
    try {
      const rawLocal = localStorage.getItem("macro-recipe-tool-html-v7");
      if (rawLocal) {
        stateLocal = JSON.parse(rawLocal);
      }
    } catch (e) {
      console.warn("Stato locale non valido, verrà ignorato.", e);
      stateLocal = null;
    }

    // 3. Nessuna riga remota → migrazione o template
    if (!row) {
      // 3a) utente “vecchio” con solo stato locale
      if (
        stateLocal &&
        typeof stateLocal === "object" &&
        Array.isArray(stateLocal.recipes) &&
        stateLocal.recipes.length > 0
      ) {
        const payload = {
          user_id: currentUser.id,
          recipes: stateLocal.recipes || [],
          planner_week: stateLocal.weekPlan || {}
        };

        const { error: insErr } = await supabaseClient
          .from(TABLE_PLANNER)
          .insert(payload);

        if (insErr) {
          console.warn("Supabase insert error (from local state)", insErr);
          return;
        }

        row = payload;
      } else {
        // 3b) utente nuovo → creo planner da recipes_template
        const { data: tpl, error: tplErr } = await supabaseClient
          .from("recipes_template")
          .select("data");

        if (tplErr) {
          console.warn("Template recipes load error:", tplErr);
          return;
        }

        const templateRecipes = (tpl || []).map(r => r.data);

        const payload = {
          user_id: currentUser.id,
          recipes: templateRecipes,
          planner_week: state && state.weekPlan ? state.weekPlan : {}
        };

        const { error: insErr2 } = await supabaseClient
          .from(TABLE_PLANNER)
          .insert(payload);

        if (insErr2) {
          console.warn("Supabase insert error (from template)", insErr2);
          return;
        } else {
          console.log(
            "Planner iniziale creato da template per",
            currentUser.email || currentUser.id
          );
          row = payload;
        }
      }
    }

    // Se ancora non ho niente, mollo
    if (!row) {
      return;
    }

    // 4. Costruisco il nextState unendo locale + remoto
    nextState =
      stateLocal && typeof stateLocal === "object"
        ? stateLocal
        : {};

    nextState.recipes  = row.recipes      || nextState.recipes  || [];
    nextState.weekPlan = row.planner_week || nextState.weekPlan || {};

    try {
      localStorage.setItem(
        "macro-recipe-tool-html-v7",
        JSON.stringify(nextState)
      );
    } catch (e) {
      console.error("Errore salvando stato locale da Supabase:", e);
    }
  } catch (e) {
    console.warn("Errore generale in loadPlannerFromSupabase:", e);
    if (typeof window.showToast === "function") {
      window.showToast(t("toasts.plannerLoadError"), "error");
    }
    return; // importantissimo: non proseguo con nextState rotto
  }

  // Se per qualche motivo nextState non è valido, non tocco nulla
  if (!nextState || !Array.isArray(nextState.recipes)) {
    console.warn("loadPlannerFromSupabase: nextState non valido, interrompo.");
    return;
  }

// 5. Aggiorno lo state globale
try {
  if (typeof window.state === "object") {
    window.state.recipes  = nextState.recipes;
    window.state.weekPlan = nextState.weekPlan || window.state.weekPlan;
    window.state.meals    = nextState.meals    || window.state.meals;

    // sicurezza: ogni meal deve avere la lista ingredienti
    Object.keys(window.state.meals || {}).forEach(k => {
      window.state.meals[k].ingredients =
        window.state.meals[k].ingredients || [];
    });

    // ricostruisco SEMPRE la ingredientLibrary
    window.state.ingredientLibrary = buildIngredientLibraryFromRecipes(
      window.state.recipes || []
    );
  }

  // assicuro i 7 giorni × 4 pasti
  if (typeof window.ensureWeekPlanDay === "function") {
    ["mon","tue","wed","thu","fri","sat","sun"]
      .forEach(window.ensureWeekPlanDay);
  }
} catch (e) {
  console.warn("Errore aggiornando state globale dal remoto:", e);
  return;
}

  // 6. Allineo i pasti del giorno con la weekPlan
  try {
    if (typeof window.syncMealsFromPlanner === "function") {
      window.syncMealsFromPlanner();
    }
  } catch (e) {
    console.warn("Errore syncMealsFromPlanner dopo loadPlannerFromSupabase:", e);
  }

  // 7. Re-render + ricalcolo automatico
  try {
    if (typeof window.autoSolveUnlocked === "function") {
      window.autoSolveUnlocked();
    }

    if (typeof window.renderRecipes === "function") window.renderRecipes();
    if (typeof window.renderMeals === "function") window.renderMeals();
    if (typeof window.renderPlanner === "function") window.renderPlanner();
    if (typeof window.renderDailyTotals === "function") window.renderDailyTotals();

    if (typeof window.showToast === "function") {
      window.showToast(t("toasts.plannerSaved"), "success");
    }
  } catch (e) {
    console.warn("Errore durante il rerender post-Supabase:", e);
    if (typeof window.showToast === "function") {
      window.showToast(t("toasts.plannerUpdateError"), "error");
    }
  }
}


async function loadWeightsForCurrentUser(){
  if (!currentUser || !currentUser.id) return;
  if (!supabaseClient) return;

  try {
    const { data, error } = await supabaseClient
      .from(TABLE_WEIGHTS)
      .select("date, weight_kg")
      .eq("user_id", currentUser.id)
      .order("date", { ascending: true });

    if (error) {
      console.warn("Errore lettura pesi da Supabase:", error);
      return;
    }

    state.pesoLog = (data || []).map(r => ({
      data: r.date,
      peso: r.weight_kg
    }));

    if (typeof window.__pesoInit === "function") {
      window.__pesoInit();
    }
  } catch(e){
    console.warn("loadWeightsForCurrentUser exception:", e);
  }
}



async function saveWeightForCurrentUser(dateISO, weightKg){
  if (!currentUser || !currentUser.id) return;
  if (!supabaseClient) return;

  const payload = {
    user_id: currentUser.id,
    date: dateISO,
    weight_kg: weightKg
  };

  try {
    const { error } = await supabaseClient
      .from(TABLE_WEIGHTS)
      .upsert(payload, { onConflict: "user_id,date" });

    if (error){
      console.warn("Errore salvataggio peso su Supabase:", error);
      if (typeof showToast === "function") {
        showToast(t("toasts.weightSaveError"), "error");
      }
    } else {
      console.log("Peso salvato su Supabase:", dateISO, weightKg);
      if (typeof showToast === "function") {
        showToast(t("toasts.weightSaved"), "success");
      }
    }
  } catch(e){
    console.warn("saveWeightForCurrentUser exception:", e);
    if (typeof showToast === "function") {
      showToast(t("toasts.weightSaveError"), "error");
    }
  }
}



async function deleteWeightForCurrentUser(dateISO){
  if (!currentUser || !currentUser.id) return;
  if (!supabaseClient) return;

  try {
    const { error } = await supabaseClient
      .from(TABLE_WEIGHTS)
      .delete()
      .eq("user_id", currentUser.id)
      .eq("date", dateISO);

    if (error){
      console.warn("Errore delete peso su Supabase:", error);
      if (typeof showToast === "function") {
        showToast(t("toasts.weightDeleteError"), "error");
      }
    } else {
      console.log("Peso eliminato su Supabase:", dateISO);
      if (typeof showToast === "function") {
        showToast(t("toasts.weightDeleted"), "warn");
      }
    }
  } catch(e){
    console.warn("deleteWeightForCurrentUser exception:", e);
    if (typeof showToast === "function") {
      showToast(t("toasts.weightDeleteError"), "error");
    }
  }
} // <-- CHIUDE deleteWeightForCurrentUser


// bridge usato dal pannello peso
window.__plannerSaveWeight = function(dateISO, weightKg){
  const v = Number(weightKg);
  if (!Number.isFinite(v) || v <= 0) return;
  saveWeightForCurrentUser(dateISO, v);
};

window.__plannerDeleteWeight = function(dateISO){
  if (!dateISO) return;
  deleteWeightForCurrentUser(dateISO);
};

     // --- SAVE planner_data su Supabase (upsert per user_id) ---

async function savePlannerToSupabase() {
  if (!currentUser) return;
  if (!state) return;    // state globale del planner

  // 🔒 Guardia anti-azzera-dati:
  // se le recipes non ci sono o sono vuote, NON salvo su Supabase.
  if (!Array.isArray(state.recipes) || state.recipes.length === 0) {
    console.warn("Skip save: recipes vuote, non sovrascrivo Supabase.");
    if (typeof showToast === "function") {
      showToast(t("toasts.noRecipesForSave"), "warn");
    }
    return;
  }

  try {
    if (typeof showToast === "function") {
      showToast(t("toasts.syncInProgress"), "info");
    }

    const payload = {
      user_id: currentUser.id,
      recipes: state.recipes,
      planner_week: state.weekPlan || {},
      updated_at: new Date().toISOString()
    };

    const { data, error } = await supabaseClient
      .from(TABLE_PLANNER)
      .upsert(payload, { onConflict: "user_id" });

    if (error) {
      console.warn("Supabase upsert planner_data error:", error);
      if (typeof showToast === "function") {
        showToast(t("toasts.plannerSaveError"), "error");
      }
    } else {
      console.log("Planner sincronizzato su Supabase.");
      if (typeof showToast === "function") {
        showToast(t("toasts.cloudSaved"), "success");
      }
    }
  } catch (e) {
    console.error("Errore inatteso nel salvataggio su Supabase:", e);
    if (typeof showToast === "function") {
      showToast(t("toasts.plannerUnexpectedSaveError"), "error");
    }
  }
}

  // Questo viene chiamato dal planner attraverso scheduleRemoteSave()
  window.__plannerRemoteSave = function(){
    if (!currentUser) return;
    clearTimeout(remoteSaveTimer);
    remoteSaveTimer = setTimeout(savePlannerToSupabase, REMOTE_SAVE_DELAY);
  };

  // --- LOGIN / LOGOUT handler ---

  async function handleLogin(ev){
    if (ev && ev.preventDefault) ev.preventDefault();
    const { emailInput, passwordInput } = getAuthEls();
    const email = emailInput ? emailInput.value.trim() : "";
    const password = passwordInput ? passwordInput.value : "";

    if (!email || !password){
      setAuthStatus(t("auth.messages.loginMissingFields"), "error");
      return;
    }

    setAuthStatus(t("auth.messages.loginInProgress"), "info");
    try {
      const { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });
      if (error) {
        console.warn("Login error", error);
                setAuthStatus(
                                t("auth.messages.loginFailedGeneric", {
                                message: error.message || "unknown error"
                            }),
                          "error"
                    );

        return;
      }
      currentUser = data.user || null;
      setAuthUILoggedIn(currentUser?.email || email);
    /*   
           // [LEGACY] Primo tentativo di caricare i settings subito dopo il login.
          // Ora i settings vengono caricati una sola volta più sotto.
         try {
        // Se hai già una funzione che carica il planner (es. loadOrInitPlannerRow),
        // lasciala com'è. Qui ci agganciamo SOLO ai settings.
        await loadSettingsForCurrentUser();
      } catch(e){
        console.warn("Errore nel loadSettingsForCurrentUser dopo login:", e);
      }
    */
      console.log("Login OK:", currentUser);

       // 1) carica settings (macro, percentuali) da Supabase
      try {
        await loadSettingsForCurrentUser();
      } catch (e) {
        console.warn("Errore nel loadSettingsForCurrentUser dopo login:", e);
      }

      // 2) carica planner_data (ricette, settimana, ecc.)
      await loadPlannerFromSupabase();

      // 3) carica storico peso dell'utente
      try {
        await loadWeightsForCurrentUser();
      } catch (e) {
        console.warn("Errore nel loadWeightsForCurrentUser dopo login:", e);
      }

      // 4) forza il render completo del planner, ora che i dati ci sono
      try {
        if (typeof window.renderRecipes === "function") window.renderRecipes();
        if (typeof window.renderMeals === "function") window.renderMeals();
        if (typeof window.renderPlanner === "function") window.renderPlanner();
        if (typeof window.renderDailyTotals === "function") window.renderDailyTotals();
      } catch (e) {
        console.warn("Render post-login fallito:", e);
      }


    } catch(e){
      console.error("Errore inatteso nel login:", e);
      setAuthStatus(t("auth.messages.loginUnexpectedError"), "error");
    }
  }

async function handleSignup(ev){
    if (ev && ev.preventDefault) ev.preventDefault();

    const { emailInput, passwordInput } = getAuthEls();
    const email = emailInput ? emailInput.value.trim() : "";
    const password = passwordInput ? passwordInput.value : "";

    if (!email || !password){
      setAuthStatus(t("auth.messages.signupMissingFields"), "error");
      return;
    }

    setAuthStatus(t("auth.messages.signupInProgress"), "info");

    try {
      const { data, error } = await supabaseClient.auth.signUp({
        email,
        password
      });

      if (error){
        console.warn("Signup error", error);
                setAuthStatus(
                                t("auth.messages.signupFailedGeneric", {
                                message: error.message || "unknown error"
                                }),
                             "error"
           );

        return;
      }

      setAuthStatus(t("auth.messages.signupSuccess"), "info");
    } catch(e){
      console.warn("Signup exception", e);
        setAuthStatus(t("auth.messages.signupUnexpectedError"), "error");
    }
  }

  async function handleLogout(ev){
    if (ev && ev.preventDefault) ev.preventDefault();
    try {
      await supabaseClient.auth.signOut();
    } catch(e){
      console.warn("Errore nel logout:", e);
    }
    currentUser = null;
    setAuthUILoggedOut();
  }

// --- INIT on load ---

async function initSupabaseAuth(){
  if (!window.supabase) {
    console.warn("Supabase JS non trovato.");
    return;
  }

  const { loginBtn, signupBtn, logoutBtn } = getAuthEls();
  if (loginBtn)  loginBtn.addEventListener("click", handleLogin);
  if (signupBtn) signupBtn.addEventListener("click", handleSignup);
  if (logoutBtn) logoutBtn.addEventListener("click", handleLogout);

  // Prova a recuperare una sessione esistente
  try {
    const { data, error } = await supabaseClient.auth.getUser();

    if (!error && data && data.user){
      currentUser = data.user;
      setAuthUILoggedIn(currentUser.email || "");
      console.log("Sessione Supabase ripristinata:", currentUser);

      // 1) carica SEMPRE i settings (macro + percentuali)
      try {
        await loadSettingsForCurrentUser();
      } catch (e) {
        console.warn("Errore nel loadSettingsForCurrentUser dopo ripristino sessione:", e);
      }

      // 2) poi carica planner_data (ricette + settimana)
      await loadPlannerFromSupabase();

      // 3) e infine carica lo storico peso dell'utente
      try {
        await loadWeightsForCurrentUser();
      } catch (e) {
        console.warn("Errore nel loadWeightsForCurrentUser dopo ripristino sessione:", e);
      }

    } else {
      setAuthUILoggedOut();
    }

  } catch(e){
    console.warn("Errore nel recupero sessione Supabase:", e);
    setAuthUILoggedOut();
  }
}

function showToast(msg, type = "info") {
  const el = document.getElementById("toast");
  if (!el) return;

  el.textContent = msg;

  // Colori base in base al tipo
  if (type === "error") {
    el.style.background = "rgba(200,0,0,0.9)";
  } else if (type === "success") {
    el.style.background = "rgba(0,140,80,0.9)";
  } else if (type === "warn") {
    el.style.background = "rgba(180,120,0,0.9)";
  } else {
    el.style.background = "rgba(0,0,0,0.80)";
  }

  el.style.display = "block";
  el.style.opacity = "1";

  clearTimeout(window.__toastTimer);
  window.__toastTimer = setTimeout(() => {
    el.style.opacity = "0";
    setTimeout(() => {
      el.style.display = "none";
    }, 300);
  }, 2200);
}

document.addEventListener("DOMContentLoaded", function(){
  initSupabaseAuth().catch(err => console.error("Init Supabase fallito:", err));
});


</script>
 <!-- Modal preview ricetta (solo descrizione) -->
<div id="recipePreviewBackdrop" class="modal-backdrop" style="display:none;">
  <div class="modal">
    <header>
      <h3 id="recipePreviewTitle" data-i18n="recipes.previewTitle">Dettaglio ricetta</h3>
      <div class="actions">
        <button
          type="button"
          class="btn-outline"
          id="recipePreviewEditBtn"
          data-i18n="recipes.previewEdit">
          Modifica
        </button>
        <button
          type="button"
          class="btn-outline"
          id="recipePreviewCloseBtn"
          data-i18n="recipes.previewClose">
          Chiudi
        </button>
      </div>

    </header>
      <div class="content">
        <p id="recipePreviewDesc"
           class="small"
           style="white-space:pre-wrap; margin-top:8px;"></p>
      </div>
    </div>
  </div>
	
</div>

  <!-- HELP DRAWER -->
  <div id="helpOverlay" class="help-overlay" aria-hidden="true"></div>
  <aside id="helpDrawer" class="help-drawer" aria-hidden="true" role="dialog" aria-label="Help">
    <div class="help-header">
      <div class="help-title" data-i18n="help.title">Guida rapida</div>
      <button type="button" class="help-close btn-outline" id="helpCloseBtn" data-i18n="help.close">Chiudi</button>
    </div>

    <div class="help-body">
      <div class="help-accordion">
        <button type="button" class="help-acc-btn" data-acc="hs1">
          <span data-i18n="help.sections.quickStart.title">Primo accesso (30s)</span>
          <span class="help-acc-icon">▾</span>
        </button>
        <div class="help-acc-panel" id="hs1">
          <div class="help-acc-content" data-i18n-html="help.sections.quickStart.body"></div>
        </div>

        <button type="button" class="help-acc-btn" data-acc="hs2">
          <span data-i18n="help.sections.targets.title">Target e giornata</span>
          <span class="help-acc-icon">▾</span>
        </button>
        <div class="help-acc-panel" id="hs2">
          <div class="help-acc-content" data-i18n-html="help.sections.targets.body"></div>
        </div>

        <button type="button" class="help-acc-btn" data-acc="hs3">
          <span data-i18n="help.sections.split.title">Split (Primo/Secondo)</span>
          <span class="help-acc-icon">▾</span>
        </button>
        <div class="help-acc-panel" id="hs3">
          <div class="help-acc-content" data-i18n-html="help.sections.split.body"></div>
        </div>

        <button type="button" class="help-acc-btn" data-acc="hs4">
          <span data-i18n="help.sections.recipes.title">Ricette e ingredienti</span>
          <span class="help-acc-icon">▾</span>
        </button>
        <div class="help-acc-panel" id="hs4">
          <div class="help-acc-content" data-i18n-html="help.sections.recipes.body"></div>
        </div>

        <button type="button" class="help-acc-btn" data-acc="hs5">
          <span data-i18n="help.sections.shopping.title">Lista spesa</span>
          <span class="help-acc-icon">▾</span>
        </button>
        <div class="help-acc-panel" id="hs5">
          <div class="help-acc-content" data-i18n-html="help.sections.shopping.body"></div>
        </div>

        <button type="button" class="help-acc-btn" data-acc="hs6">
          <span data-i18n="help.sections.data.title">Peso, storico, export</span>
          <span class="help-acc-icon">▾</span>
        </button>
        <div class="help-acc-panel" id="hs6">
          <div class="help-acc-content" data-i18n-html="help.sections.data.body"></div>
        </div>
      </div>
    </div>
  </aside>
  <!-- /HELP DRAWER -->

</body>
</html>
